<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[程序员的多肉花园]]></title>
  <subtitle><![CDATA[hello world, hello 多肉]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://elevensky.github.io/"/>
  <updated>2015-04-05T04:46:18.656Z</updated>
  <id>http://elevensky.github.io/</id>
  
  <author>
    <name><![CDATA[elevensky]]></name>
    <email><![CDATA[346800989@qq.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[js中的变量以及如何定义静态变量]]></title>
    <link href="http://elevensky.github.io/2015/04/05/js%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F/"/>
    <id>http://elevensky.github.io/2015/04/05/js中的变量以及如何定义静态变量/</id>
    <published>2015-04-05T04:41:19.000Z</published>
    <updated>2015-04-05T04:46:07.000Z</updated>
    <content type="html"><![CDATA[<p>Javascript的变量只有全局作用域和函数作用域，没有其它语言中常见的块作用域，也就是在（）和｛｝作用域中的变量。<br>变量从其声明（var myVar）或首次赋值（此前未声明）之处起开始处进入其生命期。有些文章认为在Javascript函数中，变量即用即声明是bad practice，因为只要在函数中任意地方声明了某个变量，该变量即在函数开头处就进入了其生命期，因此best practice是前向声明。但是下面代码的运行结果（在firebug中）显示变量仍然是从其声明处进入生命期的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi2</span><span class="params">()</span></span>{</div><div class="line">    <span class="built_in">console</span>.log(myVar);    <span class="comment">//this line will comlain myVar is not defined</span></div><div class="line">    <span class="keyword">var</span> myVar = <span class="number">20</span>;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"after:"</span> + myVar);</div><div class="line">}</div><div class="line"></div><div class="line">sayHi2();</div></pre></td></tr></table></figure>

<p>通过下面两种方式产生一个全局作用域的变量：</p>
<ol>
<li><p>在任何函数体之外通过var关键字声明的变量；</p>
</li>
<li><p>在任何地方（函数体内或者函数体外），对一个从未声明过的标识符赋值，从而使其成为一个变量。</p>
</li>
</ol>
<p>全局变量实际上是宿主对象的成员变量。比如在浏览器环境下，全局变量myVar实际上等于window.myVar。</p>
<p>构造函数中的变量</p>
<p>Javascript中的构造函数并没有特别的形式和限定。一般程序员会将一个函数名的首字母置为大写，如果他想将该函数当作构造函数使用的话。下面是构造函数一例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">var</span> a = <span class="number">0</span>;    <span class="comment">//声明了一个局部变量，在构造函数外任何地方都无法使用它</span></div><div class="line">    b = <span class="number">1</span>;        <span class="comment">//产生了一个全局变量</span></div><div class="line">    <span class="keyword">this</span>.c = <span class="number">2</span>;   <span class="comment">//产生了一个成员变量</span></div><div class="line">    <span class="keyword">this</span>.funcA = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{<span class="built_in">console</span>.log(<span class="string">"funcA"</span>);};  <span class="comment">//成员函数</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">funcB</span><span class="params">()</span></span>{ <span class="comment">//函数也是对象。因此，这个定义实际上声明了一个局部变量，构造函数以外任何地方都无法引用它</span></div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"funcB"</span>);</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person ();</div><div class="line"><span class="built_in">console</span>.dir(p);</div></pre></td></tr></table></figure>

<p>一般说来，构造函数只应该包含简单的赋值和函数定义（注：函数定义一般应移出构造函数，并声明在其prototype属性上）。上例的目的是为了演示函数中的变量作用域。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> </span>{</div><div class="line">    foo.counter = foo.counter || <span class="number">0</span>;  <span class="comment">// 将计数器初始化为0</span></div><div class="line">    foo.counter++;</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(foo.counter);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;=<span class="number">5</span>; i++){</div><div class="line">    foo();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上述代码运行结果（在firebug控制台中）是列出了变量c和函数funcA。注意，上述示例中var a和函数funcB的声明仍然可能是有意义的。它们可以用作构造函数中使用的辅助变量和辅助函数。</p>
<p>在C语言，以及c++在某些情况下，从函数中返回一个非基本类型的局部变量通常是不允许的。因为c/c++是按值传递，当函数结束时，其堆栈被复 位。基本类型（如int，char）其值可以直接按值传递出去，不会产生任何问题，但其它变量如果是按地址传递的话，其地址由于在堆栈中，因此该变量的数 据会随堆栈的复位而消亡。但在Javascript，Java和C#等语言中，这样做是允许的。理论上它们仍然是传值型语言，但由于它们传递的是变量的引 用，而变量始终产生在堆上（没有明确的语言规范和教程说明Javascript的变量位置），因此函数结束后，变量要么被回收（没有被引用的情况下），要 么继续有效。</p>
<p>静态变量</p>
<p>一众语言都支持静态变量，但遗憾的是Javascript并不支持。好在仍然有方法可以模拟出静态变量。静态变量的实质是它是函数作用域，但又不随每次进入函数体而被初始化。由于Javascript中函数本身也是一种对象，因此可以这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> </span>{</div><div class="line">    foo.counter = foo.counter || <span class="number">0</span>;  <span class="comment">// 将计数器初始化为0</span></div><div class="line">    foo.counter++;</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(foo.counter);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;=<span class="number">5</span>; i++){</div><div class="line">    foo();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>运行结果为输出1～6个数字。如果是匿名函数的话，可以用arguments.callee来代替函数名：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> </span>{</div><div class="line">    <span class="built_in">arguments</span>.callee.counter = <span class="built_in">arguments</span>.callee.counter || <span class="number">0</span>;  <span class="comment">// 将计数器初始化为0</span></div><div class="line">    <span class="built_in">arguments</span>.callee.counter++;</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee.counter);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;=<span class="number">5</span>; i++){</div><div class="line">    foo();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>this变量</p>
<p>在函数（不包括构造函数）中使用this变量，this的值需要等到函数调用时，由其上下文环境确定。</p>
<p>在构造函数中使用this，其结果是引用到由构造函数通过new生成的那个对象上。</p>
<p>在字面量对象中定义的函数，this引用到字面量生成的对象上。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> my = {</div><div class="line">    init : <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>._done_ != <span class="string">'undefined'</span>){</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"already inited."</span>);</div><div class="line">        }<span class="keyword">else</span>{</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"not inited."</span>);</div><div class="line">            <span class="keyword">this</span>._done_ = <span class="literal">true</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line">my.init();</div><div class="line">my.init();</div></pre></td></tr></table></figure>

<p>第一次运行my.init()的结果显示“not inited”，但第二次运行的结果就是”already inited.”。同时，结果显示this为一个Object，而非Window。因此，只要在字面量对象内声明的函数，this都会始终绑定到当前的字 面量对象上，无论是在：｛｝还是在其中的函数声明中。但要注意，this无法传递。即如果将this传递给一个函数作为参数，则在函数内部访问到的 this，并不一定是传入的this值。</p>
<p>但是，值得注意的是，在字面量对象的属性表达式中使用this，此时this并非引用到字面量对象，而是当前定义字面量的作用域对象上。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> my = {</div><div class="line">    mem : <span class="string">"hello"</span>,</div><div class="line">    msg  : <span class="keyword">this</span>.mem + <span class="string">" world!"</span></div><div class="line">};</div></pre></td></tr></table></figure>

<p>console.log(my.msg);<br>上例会显示’undefined world’。这是因为this引用到window对象上，而当前window对象中并无mem这一属性。<br>在众多的Javascript编程书籍中，没有一本提到上面的例子，这不能不说是个遗憾。使用字面量对象来构建程序中的单例对象是一种较普通的设计模式， 在定义某些变量时，不可避免地要用到其它变量。比如在定义环境配置时，常常会先定义一个home，再定义一些相对于该home的path。但是这里没有捷 径可走。下面的定义都会引起运行时错误：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> my= {</div><div class="line">    home : <span class="string">"http://home"</span>,</div><div class="line">    jsdir: my.home + <span class="string">"/js"</span>,</div><div class="line">    init : <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"init"</span>);</div><div class="line">    },</div><div class="line"></div><div class="line">    start : <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"start"</span>);</div><div class="line">        my.init();</div><div class="line">    }</div><div class="line">};</div></pre></td></tr></table></figure>

<p>my.start();<br>错误的原因可能是因为，上述语句作为一个词句执行，因此当为jsDir/imgDir赋值时，对象my还没有创建起来，因此还不能引用 my.home。而使用this之所以错误的原因，则已经在前面讲过了。然而，如果去掉第2行，则该代码可以运行，尽管我们看到第8行也引用到了 my.init();这是因为，第8行只是定义，并非执行；而第2行时需要立即对my.home进行求值，所以会发现my没有定义。这是在firebug 中看到的行为，是否有某些brower并非如此，待考。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Javascript的变量只有全局作用域和函数作用域，没有其它语言中常见的块作用域，也就是在（）和｛｝作用域中的变量。<br>变量从其声明（var myVar）或首次赋值（此前未声明）之处起开始处进入其生命期。有些文章认为在Javascript函数中，变量即用即声明是bad]]>
    </summary>
    
      <category term="语法" scheme="http://elevensky.github.io/tags/%E8%AF%AD%E6%B3%95/"/>
    
      <category term="前端" scheme="http://elevensky.github.io/categories/-categories-frontend/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Array.prototype.slice.call(arguments)]]></title>
    <link href="http://elevensky.github.io/2015/04/01/Array-prototype-slice-call-arguments/"/>
    <id>http://elevensky.github.io/2015/04/01/Array-prototype-slice-call-arguments/</id>
    <published>2015-04-01T00:47:07.000Z</published>
    <updated>2015-04-01T00:50:40.000Z</updated>
    <content type="html"><![CDATA[<p>我们知道，Array.prototype.slice.call(arguments)能将具有length属性的对象转成数组，除了IE下的节点集合（因为ie下的dom对象是以com对象的形式实现的，js对象与com对象不能进行转换）<br>如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a={length:<span class="number">2</span>,<span class="number">0</span>:<span class="string">'first'</span>,<span class="number">1</span>:<span class="string">'second'</span>};</div><div class="line"><span class="built_in">Array</span>.prototype.slice.call(a);<span class="comment">//  ["first", "second"]</span></div><div class="line"></div><div class="line"> <span class="keyword">var</span> a={length:<span class="number">2</span>};</div><div class="line"> <span class="built_in">Array</span>.prototype.slice.call(a);<span class="comment">//  [undefined, undefined]</span></div></pre></td></tr></table></figure>

<p>可能刚开始学习js的童鞋并不是很能理解这句为什么能实现这样的功能。比如我就是一个，所以，来探究一下。</p>
<p>首先，slice有两个用法，一个是String.slice,一个是Array.slice，第一个返回的是字符串，第二个返回的是数组，这里我们看第2个。</p>
<p>Array.prototype.slice.call(arguments)能够将arguments转成数组，那么就是arguments.toArray().slice();到这里，是不是就可以说Array.prototype.slice.call(arguments)的过程就是先将传入进来的第一个参数转为数组，再调用slice？</p>
<p>再看call的用法，如下例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">     <span class="built_in">console</span>.log(<span class="keyword">this</span>);    <span class="comment">// 'littledu'</span></div><div class="line">     <span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="keyword">this</span>);      <span class="comment">//  Object</span></div><div class="line">     <span class="built_in">console</span>.log(<span class="keyword">this</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>);    <span class="comment">// true</span></div><div class="line">}</div><div class="line">a.call(<span class="string">'littledu'</span>);</div></pre></td></tr></table></figure>

<p>可以看出，call了后，就把当前函数推入所传参数的作用域中去了，不知道这样说对不对，但反正this就指向了所传进去的对象就肯定的了。<br>到这里，基本就差不多了，我们可以大胆猜一下slice的内部实现，如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.prototype.slice = <span class="function"><span class="keyword">function</span><span class="params">(start,end)</span></span>{</div><div class="line">     <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line">     start = start || <span class="number">0</span>;</div><div class="line">     end = end || <span class="keyword">this</span>.length; <span class="comment">//this指向调用的对象，当用了call后，能够改变this的指向，也就是指向传进来的对象，这是关键</span></div><div class="line">     <span class="keyword">for</span>(<span class="keyword">var</span> i = start; i &lt; end; i++){</div><div class="line">          result.push(<span class="keyword">this</span>[i]);</div><div class="line">     }</div><div class="line">     <span class="keyword">return</span> result;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>大概就是这样吧，理解就行，不深究。</p>
<p>最后，附个转成数组的通用函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> toArray = <span class="function"><span class="keyword">function</span><span class="params">(s)</span></span>{</div><div class="line">    <span class="keyword">try</span>{</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(s);</div><div class="line">    } <span class="keyword">catch</span>(e){</div><div class="line">            <span class="keyword">var</span> arr = [];</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,len = s.length; i &lt; len; i++){</div><div class="line">                <span class="comment">//arr.push(s[i]);</span></div><div class="line">                   arr[i] = s[i];  <span class="comment">//据说这样比push快</span></div><div class="line">            }</div><div class="line">             <span class="keyword">return</span> arr;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>我们知道，Array.prototype.slice.call(arguments)能将具有length属性的对象转成数组，除了IE下的节点集合（因为ie下的dom对象是以com对象的形式实现的，js对象与com对象不能进行转换）<br>如：</p>
<figure cla]]>
    </summary>
    
      <category term="js" scheme="http://elevensky.github.io/tags/js/"/>
    
      <category term="前端" scheme="http://elevensky.github.io/categories/-categories-frontend/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[what is 'this'?]]></title>
    <link href="http://elevensky.github.io/2015/03/31/what-is-this/"/>
    <id>http://elevensky.github.io/2015/03/31/what-is-this/</id>
    <published>2015-03-31T03:51:39.000Z</published>
    <updated>2015-03-31T06:11:53.000Z</updated>
    <content type="html"><![CDATA[<p>呃，这次的标题有些「装逼」，首先我们从道题目开始。</p>
<p>这是道有趣的题目：考虑下面的代码，考虑 console.log 输出的值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</div><div class="line"><span class="keyword">var</span> foo = {</div><div class="line">    x: <span class="number">20</span>,</div><div class="line">    bar: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">        <span class="keyword">var</span> x = <span class="number">30</span>;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.x;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(</div><div class="line">    foo.bar(),             <span class="comment">// 1.</span></div><div class="line">    (foo.bar)(),           <span class="comment">// 2.</span></div><div class="line">    (foo.bar = foo.bar)(), <span class="comment">// 3.</span></div><div class="line">    (foo.bar, foo.bar)()   <span class="comment">// 4.</span></div><div class="line">);</div></pre></td></tr></table></figure>

<p>实际上，题目真正意思求 console.log 中依次四条语句的值。为了方便讲述，上面的语句分别标注为 1-4。</p>
<p>首先，是「1.」这条语句相对来说比较明朗（其实我们也经常这样写）。调用 foo 的 bar 方法，因此 bar 的 this 指向（作用域）为 foo，因此就等于是取 foo 上面的 x 属性（也就是 foo.x）的值，那么语句返回的值就是 20 。</p>
<p>然后是「2.」这条语句。我们可能对 Grouping Operator （也就是「()」）犹豫不决，那 么我们找找 ECMA 中相关定义 ：</p>
<blockquote>
<p>11.1.6 The Grouping Operator</p>
<p>The production PrimaryExpression : ( Expression ) is evaluated as follows:</p>
<blockquote>
<ol>
<li>Evaluate Expression. This may be of type Reference.</li>
<li>Return Result(1).</li>
</ol>
</blockquote>
<p>NOTE</p>
<p>This algorithm does not apply GetValue to Result(1). The principal<br>motivation for this is so that operators such as delete and typeof<br>may be applied to parenthesised expressions.</p>
</blockquote>
<p>因此，由于 foo.bar 是个引用「Reference」，所以使用组操作符 (foo.bar) 返回 的引用是和 foo.bar 是一样的。</p>
<p>如果还不理解，那么考虑下面的表达式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(foo.bar === (foo.bar))</div></pre></td></tr></table></figure>

<p>因此，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(foo.bar)();</div></pre></td></tr></table></figure>

<p>返回的也是 foo.x 的值，也就是 20 。</p>
<p>我们考虑语句 3. 和上面的两个语句有什么不同</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(foo.bar = foo.bar)(), <span class="comment">// 3.</span></div></pre></td></tr></table></figure>

<p>相比语句 2.，语句 3. 中的 Grouping Operator 中有赋值（「=」）语句。那么，我们首先得明白赋值语句干了啥，继续 参考对应的 ECMA 文档</p>
<blockquote>
<p>11.13.1 Simple Assignment (= )</p>
<p>The production</p>
<blockquote>
<p>   AssignmentExpression : LeftHandSideExpression = AssignmentExpression</p>
</blockquote>
<p>is evaluated as follows:</p>
<blockquote>
<ol>
<li>Evaluate LeftHandSideExpression.</li>
<li>Evaluate AssignmentExpression.<br>3.Call GetValue(Result(2)).<br>4.Call PutValue(Result(1), Result(3)).<br>5.Return Result(3).</li>
</ol>
</blockquote>
</blockquote>
<p>其中，最重要的步骤就是 PutValue，我们 继续刨根问底</p>
<blockquote>
<p>8.7.2 PutValue(V, W)</p>
<blockquote>
<ol>
<li>If Type(V) is not Reference, throw a<br>ReferenceError exception.</li>
<li>Call GetBase(V).</li>
<li>If Result(2) is null, go to step 6.</li>
<li>Call the [[Put]] method of Result(2), passing GetPropertyName(V)<br>for the property name and W for the value.</li>
<li>Return.</li>
<li>Call the [[Put]] method for the global object, passing<br>GetPropertyName(V) for the property name and W for the value.</li>
<li>Return.<br>所以，我们根据上面的定义可以得知，语句返回的是 foo.bar 的函数值。因此，赋值操作符返回的是「值（Value）」而不是「引用（Reference）」。</li>
</ol>
</blockquote>
</blockquote>
<p>因为函数体需要 this 值获取 x 属性的值，那么接下来我们考虑改函数时调用时的上下文作用域以及背后的具体流程。 尤其注意第七条规则</p>
<blockquote>
<ol>
<li>If Type(Result(1)) is Reference, Result(6) is GetBase( Result(1)).<br> Otherwise, Result(6) is null.</li>
<li>If Result(6) is an activation object, Result(7) is null. Otherwise,<br> Result(7) is the same as Result(6).</li>
<li>Call the [[Call]] method on Result(3), providing Result(7) as<br> the this value and providing the list Result(2) as the<br> argument values.</li>
</ol>
</blockquote>
<p>那么在这种情况下，GetBase 操作实际上返回的是 null，因此此条语句函数执行的作用域为 global ，在浏览器中也就是 window 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(foo.bar = foo.bar)()</div></pre></td></tr></table></figure>

<p>那么，上面的语句中我们可以得知</p>
<p>Grouping Operator 中的赋值语句返回的是 foot.bar 的函数值（「Value」）<br>该函数执行的上下文作用域为 window<br>那么，在该函数中执行获取 this.x 也就是获取 window.x 的值。因此，这条语句返回的就是 10 。如果还不理解，考虑下面的代码段</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</div><div class="line">(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.x; <span class="comment">// 这里会返回什么？</span></div><div class="line">})();</div></pre></td></tr></table></figure>

<p>如果理解了上面的语句的前因后果，那么题目中的语句 4. 就能举一反三给推导出来。首先我们来了解逗号运算符（「,」）的定义，我们就可以得之语句</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(foo.bar, foo.bar)</div></pre></td></tr></table></figure>

<p>返回的也是 foo.bar 的值「Value」而非引用「Reference」，那么接下来的事情其实就是和语句 3. 一样的了。因此，语句 4. 返回的液是 window.x 的值，也就是 10 。</p>
<p>总结下，那么上面的输出总的来说是</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">20</span> <span class="number">20</span> <span class="number">10</span> <span class="number">10</span></div></pre></td></tr></table></figure>

<hr>
<p>似乎目前为止，我们已经完全回答出了当初设定的问题。但恐怕会留下疑虑，就是传值「Value」和引用「Reference」之间到低有何不同、函数的作用域以及 this 的指向是否已经真正了解？</p>
<p>是的，这个题目已经完了，而我们的问题似乎还是没有怎麽搞清楚。OK，下次我们来详细讨论下这个问题…</p>
<p><a href="http://www.gracecode.com/posts/3018.html" target="_blank" rel="external">引用地址1</a><br><a href="http://www.gracecode.com/posts/3019.html" target="_blank" rel="external">引用地址2</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>呃，这次的标题有些「装逼」，首先我们从道题目开始。</p>
<p>这是道有趣的题目：考虑下面的代码，考虑 console.log 输出的值：</p>
<figure class="highlight javascript"><table><tr><td class="gut]]>
    </summary>
    
      <category term="js" scheme="http://elevensky.github.io/tags/js/"/>
    
      <category term="前端" scheme="http://elevensky.github.io/categories/-categories-frontend/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[简析Javascript的prototype和__proto__]]></title>
    <link href="http://elevensky.github.io/2015/03/24/%E7%AE%80%E6%9E%90Javascript%E7%9A%84prototype%E5%92%8C__proto__/"/>
    <id>http://elevensky.github.io/2015/03/24/简析Javascript的prototype和__proto__/</id>
    <published>2015-03-24T02:40:04.000Z</published>
    <updated>2015-03-24T03:29:51.000Z</updated>
    <content type="html"><![CDATA[<p>首先，需要知道以下事实：<br>Javascript的继承是基于原型链模式的。<br>Javascript的原型是一个对象。<br>Javascript的继承本质是一（或多）个对象引用了另一个对象的属性和方法。<br>直接结论：<br><strong>proto</strong> 是对象的一个内部隐藏属性，它的值是该对象的原型。<br>prototype 是函数对象的一个属性，它的值是一个对象（默认为 {} ），当该函数用作构造函数时，新创建对象的原型（<strong>proto</strong>）将指向该属性值。<br>好，show you the code:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">var</span> A = <span class="function"><span class="keyword">function</span><span class="params">(x)</span></span>{<span class="keyword">this</span>.name = x;};   <span class="comment">//定义函数 A</span></div><div class="line">&gt; <span class="keyword">var</span> a = <span class="keyword">new</span> A(<span class="string">'ima'</span>);     <span class="comment">// 通过函数A创建对象a</span></div><div class="line">&gt; a</div><div class="line">{ name: <span class="string">'ima'</span> }</div><div class="line"></div><div class="line">&gt; A.prototype       <span class="comment">//因为A.prototype默认是 {}</span></div><div class="line">{}</div><div class="line">&gt; a.__proto__       <span class="comment">//所以对象a的原型（__proto__）就是 {}</span></div><div class="line">{}</div><div class="line">&gt; A.prototype === a.__proto__   <span class="comment">//它们都是指向同一个 {}</span></div><div class="line"><span class="literal">true</span></div><div class="line">&gt; {} === {}             <span class="comment">//js中不同的空对象引用不一样，请对比上者感受一下</span></div><div class="line"><span class="literal">false</span></div></pre></td></tr></table></figure>

<p>再展示另一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">var</span> D = <span class="function"><span class="keyword">function</span><span class="params">(y)</span></span>{<span class="keyword">this</span>.desc = y;};   <span class="comment">//定义函数D</span></div><div class="line"></div><div class="line">&gt; D.prototype = a;           <span class="comment">//将D的prototype指向对象a</span></div><div class="line">{ name: <span class="string">'ima'</span> }</div><div class="line"></div><div class="line">&gt; <span class="keyword">var</span> d = <span class="keyword">new</span> D(<span class="string">'imd'</span>)      <span class="comment">//通过函数D创建对象d</span></div><div class="line">&gt; d</div><div class="line">{ desc: <span class="string">'imd'</span> }</div><div class="line"></div><div class="line">&gt; d.__proto__               <span class="comment">//对象d的原型就是对象a</span></div><div class="line">{ name: <span class="string">'ima'</span> }</div><div class="line">&gt; d.__proto__ === a</div><div class="line"><span class="literal">true</span></div><div class="line"></div><div class="line">&gt; d.name                    <span class="comment">//d"继承"了对象a的属性，实质是引用</span></div><div class="line"><span class="string">'ima'</span></div><div class="line">&gt; a.name = <span class="string">'iama!'</span>          <span class="comment">//更改a.name, d.name也发生了改变</span></div><div class="line">&gt; d.name                    <span class="comment">//具体可以查看Javascript原型链原理</span></div><div class="line"><span class="string">'iama!'</span></div><div class="line"></div><div class="line"><span class="comment">/* 需要注意的是：非函数对象是没有prototype属性的：*/</span></div><div class="line">&gt; a.prototype</div><div class="line"><span class="literal">undefined</span></div><div class="line">&gt; d.prototype</div><div class="line"><span class="literal">undefined</span></div><div class="line"></div><div class="line"><span class="comment">/* 而函数是有__proto__的，因为函数也是对象：*/</span></div><div class="line">&gt; A.__proto__</div><div class="line">[<span class="built_in">Function</span>: Empty]       <span class="comment">//函数的默认原型是空函数，正如对象的默认原型是空对象</span></div><div class="line">&gt; A.__proto__.toString()</div><div class="line"><span class="string">'function Empty() {}'</span></div></pre></td></tr></table></figure>

<p>再次总结：<br><strong>protot</strong>指向对象的原型。<br>prototype是函数的属性，作为使用new创建的函数实例的原型。<br>建议阅读阮一峰的Javascript继承机制的设计思想，简单通俗地了解为什么Javascript采用prototype这种方式实现继承。<br>题外话：（关于constructor）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 对象a的构造函数是函数A */</span></div><div class="line">&gt; a.constructor.toString()</div><div class="line"><span class="string">'function (x){this.name = x;}'</span></div><div class="line">&gt; a.constructor === A</div><div class="line"><span class="literal">true</span></div><div class="line"></div><div class="line"><span class="comment">/* 因为A是一个函数对象，所以A的构造函数就是function的构造函数Function */</span></div><div class="line">&gt; A.constructor</div><div class="line">[<span class="built_in">Function</span>: <span class="built_in">Function</span>]</div><div class="line">&gt; A.constructor.toString()</div><div class="line"><span class="string">'function Function() { [native code] }'</span></div><div class="line">&gt; A.constructor === <span class="built_in">Function</span>.constructor</div><div class="line"><span class="literal">true</span></div><div class="line"><span class="comment">/* 函数A的原型(__protot__)就是它的构造函数（Function）的prototype */</span></div><div class="line">&gt; A.constructor === <span class="built_in">Function</span></div><div class="line"><span class="literal">true</span></div><div class="line">&gt; <span class="built_in">Function</span>.prototype</div><div class="line">[<span class="built_in">Function</span>: Empty]</div><div class="line">&gt; A.__proto__ === <span class="built_in">Function</span>.prototype</div><div class="line"><span class="literal">true</span></div><div class="line"></div><div class="line"><span class="comment">/* 但是 ！！！ */</span></div><div class="line"><span class="comment">/* 继承了对象a的d，它的构造函数不是D，而是A */</span></div><div class="line">&gt; d.constructor.toString()</div><div class="line"><span class="string">'function (x){this.name = x;}'</span></div><div class="line"></div><div class="line">&gt; d.constructor === a.constructor</div><div class="line"><span class="literal">true</span></div><div class="line"></div><div class="line">&gt; d.constructor === A</div><div class="line"><span class="literal">true</span></div></pre></td></tr></table></figure>

<p>以上代码在Node.js v0.10.30环境下测试。<br><a href="http://shaopenghe.github.io/2014/07/12/javascript-prototype-protot.html" target="_blank" rel="external">引用地址</a><br><a href="http://www.cnblogs.com/snandy/archive/2012/09/01/2664134.html" target="_blank" rel="external">扩展阅读</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>首先，需要知道以下事实：<br>Javascript的继承是基于原型链模式的。<br>Javascript的原型是一个对象。<br>Javascript的继承本质是一（或多）个对象引用了另一个对象的属性和方法。<br>直接结论：<br><strong>proto</stro]]>
    </summary>
    
      <category term="js" scheme="http://elevensky.github.io/tags/js/"/>
    
      <category term="前端" scheme="http://elevensky.github.io/categories/-categories-frontend/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[nodejs学习笔记]]></title>
    <link href="http://elevensky.github.io/2015/03/23/nodejs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://elevensky.github.io/2015/03/23/nodejs学习笔记/</id>
    <published>2015-03-23T14:40:04.000Z</published>
    <updated>2015-03-24T02:29:49.000Z</updated>
    <content type="html"><![CDATA[<h2 id="别被Express的API搞晕了">别被Express的API搞晕了</h2>
<p>先来一段最简单的node版hello world</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line">http.createServer(<span class="function"><span class="keyword">function</span> <span class="params">(req, res)</span> </span>{</div><div class="line">    res.writeHead(<span class="number">200</span>, {<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>});</div><div class="line">    res.end(<span class="string">'Hello World\n'</span>);</div><div class="line">}).listen(<span class="number">1337</span>, <span class="string">'127.0.0.1'</span>);</div></pre></td></tr></table></figure>

<p>上面这段代码来自nodejs的官网，非常简单，就是来一个请求，就用传给createServer的匿名函数来处理请求。</p>
<p>下面来看看使用Express的代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> app = express();</div><div class="line"><span class="comment">//...中间忽略</span></div><div class="line">http.createServer(app).listen(app.get(<span class="string">'port'</span>), <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Express server listening on port '</span> + app.get(<span class="string">'port'</span>));</div><div class="line">});</div></pre></td></tr></table></figure>

<p>对比可以看出，执行express()后，会返回一个函数，赋值给app，app的签名应该为</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span><span class="params">(req,res)</span></span>{<span class="comment">//...}</span></div></pre></td></tr></table></figure>

<p>然后请求都会被app这个函数处理（因为这个app是执行express后的结果，下面将不加区分的使用app和express两个词）。<br>另外一点最新的express中创建http服务器的过程已经封装到了如下代码中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">app.listen = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">  <span class="keyword">var</span> server = http.createServer(<span class="keyword">this</span>);</div><div class="line">  <span class="keyword">return</span> server.listen.apply(server, <span class="built_in">arguments</span>);</div><div class="line">};</div></pre></td></tr></table></figure>

<p>可以认为，在express内部，有一个函数的数组，暂时叫这个数组tasks，每来一个请求express内部会依次执行这个数组中的函数（这里说依次并不严谨，每个函数必须满足一定条件才行，这个后面说），应该可以想到，在这个函数数组里，每个函数的签名应该像下面那样</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span><span class="params">(req,res)</span></span>{<span class="comment">//...}</span></div></pre></td></tr></table></figure>

<p>但是，实际上是</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span><span class="params">(req,res，next)</span></span>{<span class="comment">//...}</span></div></pre></td></tr></table></figure>

<p>这个next，是指下一个函数。后面我们会写一些试验来体验一下这个next，先总结一下：<br>对于一个典型的使用express的app.js（这个满大街都是代码，就不贴了），做了以下几件事</p>
<ol>
<li>导入相关模块</li>
<li>执行过 var app = express() 后，使用app.set 设置express内部的一些参数（options）使用app.use 来注册函数，可以简单的认为是向那个（被我叫做）tasks的数组进行push操作</li>
<li>通过http.createServer 用app来处理请求</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="别被Express的API搞晕了">别被Express的API搞晕了</h2>
<p>先来一段最简单的node版hello world</p>
<figure class="highlight javascript"><table><tr><td class="g]]>
    </summary>
    
      <category term="nodejs" scheme="http://elevensky.github.io/tags/nodejs/"/>
    
      <category term="前端" scheme="http://elevensky.github.io/categories/-categories-frontend/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[]]></title>
    <link href="http://elevensky.github.io/2015/03/12/nodejs%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6/"/>
    <id>http://elevensky.github.io/2015/03/12/nodejs模块机制/</id>
    <published>2015-03-12T00:36:29.000Z</published>
    <updated>2015-03-12T00:37:23.000Z</updated>
    <content type="html"><![CDATA[<p>title: nodejs模块机制<br>date: 2015-03-12 08:36:29<br>categories:前端<br>tags:</p>
<ul>
<li>node<br>keywords:</li>
</ul>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<p>title: nodejs模块机制<br>date: 2015-03-12 08:36:29<br>categories:前端<br>tags:</p>
<ul>
<li>node<br>keywords:</li>
</ul>
<hr>
]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[mac下安装启动mongodb]]></title>
    <link href="http://elevensky.github.io/2015/03/05/mac%E4%B8%8B%E5%AE%89%E8%A3%85%E5%90%AF%E5%8A%A8mongodb/"/>
    <id>http://elevensky.github.io/2015/03/05/mac下安装启动mongodb/</id>
    <published>2015-03-04T17:10:48.000Z</published>
    <updated>2015-03-04T17:25:03.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Mac_OSX_10-9-4下使用Homebrew安装MongoDB">Mac OSX 10.9.4下使用Homebrew安装MongoDB</h2>
<h3 id="安装Homebrew">安装Homebrew</h3>
<p>Homebrew是Mac OSX下一个包依赖管理工具，用它来安装软件非常的方便只需要brew install 软件名这一条命令就可以将你所需要的软件安装好，不用再操心安装过程中软件的依赖问题，这些问题Homebrew统统帮你搞定，Homebrew的官网：<a href="http://brew.sh/" target="_blank" rel="external">http://brew.sh/</a> 在官网上对Homebrew的安装和用法有详细的描述这里就不多扯了。如果你还没有安装，还等什么赶紧动手安装吧！:]</p>
<p>Homebrew安装方法也很简单：打开终端，然后输入命令</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ruby <span class="operator">-e</span> <span class="string">"<span class="variable">$(curl -fsSL https://raw.github.com/mxcl/homebrew/go)</span>"</span></div></pre></td></tr></table></figure>

<p>对，就是这么简单一条命令就可以将神器Homebrew安装好.</p>
<p>安装MongoDB</p>
<p>MongoDB是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。 MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。他支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引.</p>
<p>进入正题开始用Homebrew安装主角MongoDB～～～</p>
<p>在终端输入如下命令即可安装MongoDB</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew <span class="operator"><span class="keyword">install</span> mongodb</span></div></pre></td></tr></table></figure>

<p>用Homebrew安装软件是不是很爽，耐心等待一会儿MongoDB就会安装好了……</p>
<p>测试MongoDB是否安装成功</p>
<p>在终端输入如下命令进行测试:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mongod</div></pre></td></tr></table></figure>

<p>mongod命令是用来启动MongoDB的服务的。</p>
<h3 id="mongodb启动失败">mongodb启动失败</h3>
<p>执行mongos命令后返回了一堆错误信息，如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">mongod --help for help and startup options</div><div class="line">2014-07-17T21:34:21.732+0800 [initandlisten] MongoDB starting : pid=13117 port=27017  dbpath=/data/db 64-bit host=zhcmacbook-pro.local</div><div class="line">2014-07-17T21:34:21.732+0800 [initandlisten] db version v2.6.3</div><div class="line">2014-07-17T21:34:21.732+0800 [initandlisten] git version: nogitversion</div><div class="line">2014-07-17T21:34:21.732+0800 [initandlisten] build info: Darwin minimavericks.local 13.2.0  Darwin Kernel Version 13.2.0: Thu Apr 17 23:03:13 PDT 2014; root:xnu-2422.100.13~1/ RELEASE_X86_64 x86_64 BOOST_LIB_VERSION=1_49</div><div class="line">2014-07-17T21:34:21.732+0800 [initandlisten] allocator: tcmalloc</div><div class="line">2014-07-17T21:34:21.732+0800 [initandlisten] options: {}</div><div class="line">2014-07-17T21:34:21.733+0800 [initandlisten] exception in initAndListen: 10296</div><div class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></div><div class="line">  ERROR: dbpath (/data/db) does not exist.</div><div class="line">  Create this directory or give existing directory in --dbpath.</div><div class="line">  See http://dochub.mongodb.org/core/startingandstoppingmongo</div><div class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></div><div class="line">, terminating</div><div class="line">2014-07-17T21:34:21.733+0800 [initandlisten] dbexit:</div><div class="line">2014-07-17T21:34:21.733+0800 [initandlisten] shutdown: going to close listening sockets...</div><div class="line">2014-07-17T21:34:21.733+0800 [initandlisten] shutdown: going to flush diaglog...</div><div class="line">2014-07-17T21:34:21.733+0800 [initandlisten] shutdown: going to close sockets...</div><div class="line">2014-07-17T21:34:21.733+0800 [initandlisten] shutdown: waiting for fs preallocator...</div><div class="line">2014-07-17T21:34:21.733+0800 [initandlisten] shutdown: lock for final commit...</div><div class="line">2014-07-17T21:34:21.733+0800 [initandlisten] shutdown: final commit...</div><div class="line">2014-07-17T21:34:21.733+0800 [initandlisten] shutdown: closing all files...</div><div class="line">2014-07-17T21:34:21.733+0800 [initandlisten] closeAllFiles() finished</div><div class="line">2014-07-17T21:34:21.733+0800 [initandlisten] dbexit: really exiting now</div></pre></td></tr></table></figure>

<p>这么一堆错误信息，重点是这几句</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ERROR: dbpath (/data/db) does <span class="operator">not</span> exist. Create this <span class="built_in">directory</span> <span class="operator">or</span> give existing <span class="built_in">directory</span> <span class="operator">in</span> –dbpath. See <span class="keyword">http</span>://dochub.mongodb.org/core/startingandstoppingmongo</div></pre></td></tr></table></figure>

<p>错误信息的意思是dbpath (/data/db)不存在，需要创建/data/db这个目录或者使用—dbpath参数项指定一个已经存在的目录。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">dbpath</span> (/<span class="typedef"><span class="keyword">data</span>/db)这个目录是用来存储<span class="type">MongoDB</span>数据文件的地方</span></div></pre></td></tr></table></figure>

<p>既然不存在/data/db那我们就创建这个目录</p>
<p>首先在终端输入cd /命令返回到磁盘根目录</p>
<p>然后输入mkdir -p /data/db创建/data/db</p>
<p>再次输入mongos命令启动MongoDB的服务，服务又退出了返回一堆信息如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">mongod <span class="comment">--help for help and startup options</span></div><div class="line">2014-07-17T23:56:40.285+0800 [initandlisten] MongoDB starting : pid=21182 port=27017  dbpath=/data/db 64-bit host=zhcmacbook-pro.local</div><div class="line">2014-07-17T23:56:40.285+0800 [initandlisten] db version v2.6.3</div><div class="line">2014-07-17T23:56:40.285+0800 [initandlisten] git version: nogitversion</div><div class="line">2014-07-17T23:56:40.285+0800 [initandlisten] build info: Darwin minimavericks.local 13.2.0  Darwin Kernel Version 13.2.0: Thu Apr 17 23:03:13 PDT 2014; root:xnu-2422.100.13~1/ RELEASE_X86_64 x86_64 BOOST_LIB_VERSION=1_49</div><div class="line">2014-07-17T23:56:40.285+0800 [initandlisten] allocator: tcmalloc</div><div class="line">2014-07-17T23:56:40.285+0800 [initandlisten] options: {}</div><div class="line">2014-07-17T23:56:40.287+0800 [initandlisten] exception in initAndListen: 10309 Unable to  <span class="operator"><span class="keyword">create</span>/<span class="keyword">open</span> <span class="keyword">lock</span> file: /<span class="keyword">data</span>/db/mongod.<span class="keyword">lock</span> errno:<span class="number">13</span> Permission denied <span class="keyword">Is</span> a mongod  instance already running?, terminating</span></div><div class="line"><span class="number">2014</span>-<span class="number">07</span>-<span class="number">17</span>T23:<span class="number">56</span>:<span class="number">40.287</span>+<span class="number">0800</span> [initandlisten] dbexit:</div><div class="line"><span class="number">2014</span>-<span class="number">07</span>-<span class="number">17</span>T23:<span class="number">56</span>:<span class="number">40.287</span>+<span class="number">0800</span> [initandlisten] shutdown: going <span class="keyword">to</span> <span class="keyword">close</span> listening sockets...</div><div class="line"><span class="number">2014</span>-<span class="number">07</span>-<span class="number">17</span>T23:<span class="number">56</span>:<span class="number">40.287</span>+<span class="number">0800</span> [initandlisten] shutdown: going <span class="keyword">to</span> <span class="keyword">flush</span> diaglog...</div><div class="line"><span class="number">2014</span>-<span class="number">07</span>-<span class="number">17</span>T23:<span class="number">56</span>:<span class="number">40.287</span>+<span class="number">0800</span> [initandlisten] shutdown: going <span class="keyword">to</span> <span class="keyword">close</span> sockets...</div><div class="line"><span class="number">2014</span>-<span class="number">07</span>-<span class="number">17</span>T23:<span class="number">56</span>:<span class="number">40.287</span>+<span class="number">0800</span> [initandlisten] shutdown: waiting <span class="keyword">for</span> fs preallocator...</div><div class="line"><span class="number">2014</span>-<span class="number">07</span>-<span class="number">17</span>T23:<span class="number">56</span>:<span class="number">40.287</span>+<span class="number">0800</span> [initandlisten] shutdown: <span class="keyword">lock</span> <span class="keyword">for</span> final <span class="keyword">commit</span>...</div><div class="line"><span class="number">2014</span>-<span class="number">07</span>-<span class="number">17</span>T23:<span class="number">56</span>:<span class="number">40.287</span>+<span class="number">0800</span> [initandlisten] shutdown: final <span class="keyword">commit</span>...</div><div class="line"><span class="number">2014</span>-<span class="number">07</span>-<span class="number">17</span>T23:<span class="number">56</span>:<span class="number">40.287</span>+<span class="number">0800</span> [initandlisten] shutdown: closing <span class="keyword">all</span> files...</div><div class="line"><span class="number">2014</span>-<span class="number">07</span>-<span class="number">17</span>T23:<span class="number">56</span>:<span class="number">40.288</span>+<span class="number">0800</span> [initandlisten] closeAllFiles() finished</div><div class="line"><span class="number">2014</span>-<span class="number">07</span>-<span class="number">17</span>T23:<span class="number">56</span>:<span class="number">40.288</span>+<span class="number">0800</span> [initandlisten] shutdown: removing fs <span class="keyword">lock</span>...</div><div class="line"><span class="number">2014</span>-<span class="number">07</span>-<span class="number">17</span>T23:<span class="number">56</span>:<span class="number">40.288</span>+<span class="number">0800</span> [initandlisten] couldn<span class="string">'t remove fs lock errno:9 Bad file   descriptor</span></div><div class="line">2014-07-17T23:56:40.288+0800 [initandlisten] dbexit: really exiting now</div></pre></td></tr></table></figure>

<p>出错原因是这几句log</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">create</span>/<span class="keyword">open</span> <span class="keyword">lock</span> file: /<span class="keyword">data</span>/db/mongod.<span class="keyword">lock</span> errno:<span class="number">13</span> Permission denied <span class="keyword">Is</span> a mongod  instance already running?, terminating</span></div></pre></td></tr></table></figure>

<p>意思是不创建和打开/data/db/mongod.lock这个文件，原因是Permission denied（权限拒绝），看来是当前用户执行mongod这个命令时，对/data/db这个目录没有操作权限，OK，知道原因就好办了，给/data/db加上权限。</p>
<p>在终端输入如下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">sudo</span> chown -<span class="type">R</span>  当前登录的用户名 /<span class="typedef"><span class="keyword">data</span></span></div></pre></td></tr></table></figure>

<p>再次在终端输入 <strong>mongod</strong> 启动MongoDB的服务，返回如下信息：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">mongod <span class="comment">--help for help and startup options</span></div><div class="line"><span class="number">2014</span>-<span class="number">07</span>-<span class="number">18</span>T01:<span class="number">29</span>:<span class="number">23.286</span>+<span class="number">0800</span> [initandlisten] MongoDB starting : pid=<span class="number">22420</span> port=<span class="number">27017</span>  dbpath=/data/db <span class="number">64</span>-bit host=zhcmacbook-pro.<span class="built_in">local</span></div><div class="line"><span class="number">2014</span>-<span class="number">07</span>-<span class="number">18</span>T01:<span class="number">29</span>:<span class="number">23.286</span>+<span class="number">0800</span> [initandlisten] db <span class="built_in">version</span> v2<span class="number">.6</span><span class="number">.3</span></div><div class="line"><span class="number">2014</span>-<span class="number">07</span>-<span class="number">18</span>T01:<span class="number">29</span>:<span class="number">23.286</span>+<span class="number">0800</span> [initandlisten] git <span class="built_in">version</span>: nogitversion</div><div class="line"><span class="number">2014</span>-<span class="number">07</span>-<span class="number">18</span>T01:<span class="number">29</span>:<span class="number">23.286</span>+<span class="number">0800</span> [initandlisten] build info: Darwin minimavericks.<span class="built_in">local</span> <span class="number">13.2</span><span class="number">.0</span>  Darwin Kernel Version <span class="number">13.2</span><span class="number">.0</span>: Thu Apr <span class="number">17</span> <span class="number">23</span>:<span class="number">03</span>:<span class="number">13</span> PDT <span class="number">2014</span>; root:xnu-<span class="number">2422.100</span><span class="number">.13</span>~<span class="number">1</span>/ RELEASE_X86_64 x86_64 BOOST_LIB_VERSION=<span class="number">1</span>_49</div><div class="line"><span class="number">2014</span>-<span class="number">07</span>-<span class="number">18</span>T01:<span class="number">29</span>:<span class="number">23.286</span>+<span class="number">0800</span> [initandlisten] allocator: tcmalloc</div><div class="line"><span class="number">2014</span>-<span class="number">07</span>-<span class="number">18</span>T01:<span class="number">29</span>:<span class="number">23.287</span>+<span class="number">0800</span> [initandlisten] options: {}</div><div class="line"><span class="number">2014</span>-<span class="number">07</span>-<span class="number">18</span>T01:<span class="number">29</span>:<span class="number">23.288</span>+<span class="number">0800</span> [initandlisten] journal dir=/data/db/journal</div><div class="line"><span class="number">2014</span>-<span class="number">07</span>-<span class="number">18</span>T01:<span class="number">29</span>:<span class="number">23.288</span>+<span class="number">0800</span> [initandlisten] recover : no journal <span class="built_in">files</span> present, no   recovery needed</div><div class="line"><span class="number">2014</span>-<span class="number">07</span>-<span class="number">18</span>T01:<span class="number">29</span>:<span class="number">23.437</span>+<span class="number">0800</span> [initandlisten] waiting <span class="keyword">for</span> connections <span class="command"><span class="keyword">on</span> <span class="title">port</span> <span class="title">27017</span></span></div></pre></td></tr></table></figure>

<p>终于启动成功了，然后再打开一个新的终端窗口输入 <strong>mongo</strong> 命令，返回如下信息：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">~ $ mongo</div><div class="line">MongoDB <span class="built_in">shell</span> <span class="built_in">version</span>: <span class="number">2.6</span><span class="number">.3</span></div><div class="line">connecting <span class="built_in">to</span>: test</div><div class="line">Welcome <span class="built_in">to</span> <span class="operator">the</span> MongoDB <span class="built_in">shell</span>.</div><div class="line">For interactive help, type <span class="string">"help"</span>.</div><div class="line">For more comprehensive documentation, see</div><div class="line"><span class="keyword">http</span>://docs.mongodb.org/</div><div class="line">Questions? Try <span class="operator">the</span> support group</div><div class="line"><span class="keyword">http</span>://groups.google.com/group/mongodb-user</div><div class="line">&gt;</div></pre></td></tr></table></figure>

<p>哦耶！，成功进入MongoDB的命令行模式，到这里MongoDB就安装好了！:] :] :]……</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Mac_OSX_10-9-4下使用Homebrew安装MongoDB">Mac OSX 10.9.4下使用Homebrew安装MongoDB</h2>
<h3 id="安装Homebrew">安装Homebrew</h3>
<p>Homebrew是Mac OSX下]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[js继承机制]]></title>
    <link href="http://elevensky.github.io/2015/02/27/js%E7%BB%A7%E6%89%BF%E6%9C%BA%E5%88%B6/"/>
    <id>http://elevensky.github.io/2015/02/27/js继承机制/</id>
    <published>2015-02-27T11:39:04.000Z</published>
    <updated>2015-02-27T11:42:36.000Z</updated>
    <content type="html"><![CDATA[<p>js的继承机制到底是什么。<br>即便如“阮一峰”老师这样的大牛，也不禁发出这样的感叹</p>
<p><strong>我花了很多时间，学习这个部分，还做了很多笔记。但是都属于强行记忆，无法从根本上理解。</strong></p>
<p>作为愚钝如我等码农，也是搞的头晕脑胀，基本理念看了很多材料也翻得差不多，但这杯水还是有点混，没有如自己瓶装的矿泉水那么清澈通透。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>js的继承机制到底是什么。<br>即便如“阮一峰”老师这样的大牛，也不禁发出这样的感叹</p>
<p><strong>我花了很多时间，学习这个部分，还做了很多笔记。但是都属于强行记忆，无法从根本上理解。</strong></p>
<p>作为愚钝如我等码农，也是搞的头晕脑胀，]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[你是否强大到不需要信仰]]></title>
    <link href="http://elevensky.github.io/2015/02/25/%E4%BD%A0%E6%98%AF%E5%90%A6%E5%BC%BA%E5%A4%A7%E5%88%B0%E4%B8%8D%E9%9C%80%E8%A6%81%E4%BF%A1%E4%BB%B0/"/>
    <id>http://elevensky.github.io/2015/02/25/你是否强大到不需要信仰/</id>
    <published>2015-02-25T11:29:31.000Z</published>
    <updated>2015-02-25T13:26:06.000Z</updated>
    <content type="html"><![CDATA[<p>很多年前，当时年少轻狂不知敬畏，对于信仰我只是认为是宗教想出来，愚弄弱者的东西。</p>
<p>给那些在黑暗中找不到方向，徘徊的人以指引。那时候信仰在我的眼里仅仅是给弱者以支撑的依靠。</p>
<p>作为强者，是不需要的。</p>
<p>就如一个冷酷的杀手，一个专注的狙击手。</p>
<p>他不需要去相信神的眷顾，他需要做的仅仅是磨练自己的技艺，控制自己的呼吸，定格那早已染色的画面—-手起，刀落，头断，离去。</p>
<p>很小的时候我就体味到孤独的滋味，在孤独中我感受到了自己的无力，我感受到了自己那弱小的力量，你无法改变决定任何事，天地苍茫，你只能做一片树叶，随这冷然的秋风飘落到大地上，最终化为尘土。</p>
<p>这片天空本就一片漆黑，孤独让我回头，那一刹那看到了这片黑夜中，微弱的一丝光芒。那是我自己的光芒，我惊恐的用双手拢起，生怕他被这漆黑的夜空扑灭。从那一刻我便知道自己拥有这片黑夜中最珍贵的东西。我有一束属于自己的光芒，我想那便是我的<strong>信仰</strong>，在这片漆黑的一方大地上，孤独帮我找到了属于自己的信仰。</p>
<p>我将用一生的时间来守护和壮大心中的这束光芒，总有一天他会如这皓月般明亮，指引我前进。</p>
<p>但是就是这孤独让我看到了自己那弱小力量，虽然那力量若有若无，但我却看到了他散发的微光。于是我想让着光变的更强，强到足以照亮我脚下这片漆黑的大地。<br>给我以前进的方向。</p>
<p>这漫天的繁星，是远去的一轮轮皓月，而不是你眼中的点点繁星。</p>
<p>信仰是予以强者的肯定，的鼓励<br>信仰是给与弱者的支撑，的依靠</p>
<p>上帝不是你用来乞讨的神，上帝是这黑夜漫天星辰散发的万般光芒—-<strong>虽触不可及，却仰望可见</strong>。</p>
<p><em>最初的夜空满是繁星，但却没有一颗属于你。你要找的是那颗能捧在手心的那轮皓月。</em></p>
<p>人需要信仰，因为你是人。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>很多年前，当时年少轻狂不知敬畏，对于信仰我只是认为是宗教想出来，愚弄弱者的东西。</p>
<p>给那些在黑暗中找不到方向，徘徊的人以指引。那时候信仰在我的眼里仅仅是给弱者以支撑的依靠。</p>
<p>作为强者，是不需要的。</p>
<p>就如一个冷酷的杀手，一个专注的狙击手]]>
    </summary>
    
      <category term="生活" scheme="http://elevensky.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[nodejs中exports和module.exports区别]]></title>
    <link href="http://elevensky.github.io/2015/02/25/nodejs%E4%B8%ADexports%E5%92%8Cmodule-exports%E5%8C%BA%E5%88%AB/"/>
    <id>http://elevensky.github.io/2015/02/25/nodejs中exports和module-exports区别/</id>
    <published>2015-02-25T06:36:22.000Z</published>
    <updated>2015-02-25T07:01:36.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Node-js中exports和module-exports有什么不同？">Node.js中exports和module.exports有什么不同？</h2>
<p>你肯定对Node.js模块中用来创建函数的exports对象很熟悉（假设一个名为rocker.js的文件）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">exports.name = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'My name is Lemmy Kilmister'</span>);</div><div class="line">};</div></pre></td></tr></table></figure>

<a id="more"></a>
<p>然后你在另一个文件中调用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> rocker = <span class="built_in">require</span>(<span class="string">'./rocker.js'</span>);</div><div class="line">rocker.name(); <span class="comment">// 'My name is Lemmy Kilmister'</span></div></pre></td></tr></table></figure>

<p>但是module.exports到底是个什么玩意儿? 它合法吗？</p>
<p>令人吃惊的是- <em>module.exports</em> 是真实存在的东西。exports只是module.exports的辅助方法。你的模块最终返回module.exports给调用者，而不是exports。exports所做的事情是收集属性，如果module.exports当前没有任何属性的话，exports会把这些属性赋予module.exports。如果module.exports已经存在一些属性的话，那么exports中所用的东西都会被忽略。</p>
<p>把下面的内容放到rocker.js:</p>
<p>module.exports = ‘ROCK IT!’;<br>exports.name = function() {<br>    console.log(‘My name is Lemmy Kilmister’);<br>};<br>然后把下面的内容放到另一个文件中，执行它：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> rocker = <span class="built_in">require</span>(<span class="string">'./rocker.js'</span>);</div><div class="line">rocker.name(); <span class="comment">// TypeError: Object ROCK IT! has no method 'name'</span></div></pre></td></tr></table></figure>

<p>rocker模块完全忽略了exports.name，然后返回了一个字符串’ROCK IT!’。通过上面的例子，你可能认识到你的模块不一定非得是模块实例（module instances）。你的模块可以是任何合法的JavaScript对象 - boolean，number，date，JSON， string，function，array和其他。你的模块可以是任何你赋予module.exports的值。如果你没有明确的给module.exports设置任何值，那么exports中的属性会被赋给module.exports中，然后并返回它。</p>
<p>在下面的情况下，你的模块是一个类：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span><span class="params">(name, age)</span> </span>{</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.about = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name +<span class="string">' is '</span>+ <span class="keyword">this</span>.age +<span class="string">' years old'</span>);</div><div class="line">    };</div><div class="line">};</div></pre></td></tr></table></figure>

<p>然后你应该这样使用它：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> Rocker = <span class="built_in">require</span>(<span class="string">'./rocker.js'</span>);</div><div class="line"><span class="keyword">var</span> r = <span class="keyword">new</span> Rocker(<span class="string">'Ozzy'</span>, <span class="number">62</span>);</div><div class="line">r.about(); <span class="comment">// Ozzy is 62 years old</span></div></pre></td></tr></table></figure>

<p>在下面的情况下，你的模块是一个数组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = [<span class="string">'Lemmy Kilmister'</span>, <span class="string">'Ozzy Osbourne'</span>, <span class="string">'Ronnie James Dio'</span>, <span class="string">'Steven Tyler'</span>, <span class="string">'Mick Jagger'</span>];</div></pre></td></tr></table></figure>

<p>然后你应该这样使用它：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> rocker = <span class="built_in">require</span>(<span class="string">'./rocker.js'</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Rockin in heaven: '</span> + rocker[<span class="number">2</span>]); <span class="comment">//Rockin in heaven: Ronnie James Dio</span></div></pre></td></tr></table></figure>

<p>现在你应该找到要点了 - 如果你想要你的模块成为一个特别的对象类型，那么使用module.exports；如果你希望你的模块成为一个传统的模块实例（module instance），使用exports。</p>
<p>把属性赋予module.exports的结果与把属性赋予给exports是一样的。看下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">module</span>.exports.name = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'My name is Lemmy Kilmister'</span>);</div><div class="line">};</div></pre></td></tr></table></figure>

<p>下面这个做的是一样的事情：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">exports.name = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'My name is Lemmy Kilmister'</span>);</div><div class="line">};</div></pre></td></tr></table></figure>

<p>但是请注意，它们并不是一样的东西。就像我之前说的module.exports是真实存在的东西，exports只是它的辅助方法。话虽如此，exports还是推荐的对象，除非你想把你模块 的对象类型从传统的模块实例（module instance）修改为其他的。</p>
<p>希望这篇文章能帮助你理解exports和module.exports之间的不同，并且能进一步的理解模块在Node.js中是怎么工作的。</p>
<h2 id="转载">转载</h2>
<p><em>转载地址</em> ：<a href="http://weizhifeng.net/node-js-exports-vs-module-exports.html" target="_blank" rel="external">http://weizhifeng.net/node-js-exports-vs-module-exports.html</a><br><em>英文原址</em> ：<a href="http://www.hacksparrow.com/node-js-exports-vs-module-exports.html" target="_blank" rel="external">http://www.hacksparrow.com/node-js-exports-vs-module-exports.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Node-js中exports和module-exports有什么不同？">Node.js中exports和module.exports有什么不同？</h2>
<p>你肯定对Node.js模块中用来创建函数的exports对象很熟悉（假设一个名为rocker.js的文件）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">exports.name = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'My name is Lemmy Kilmister'</span>);</div><div class="line">};</div></pre></td></tr></table></figure>

]]>
    
    </summary>
    
      <category term="nodejs" scheme="http://elevensky.github.io/tags/nodejs/"/>
    
      <category term="前端" scheme="http://elevensky.github.io/categories/-categories-frontend/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Node.js 概述]]></title>
    <link href="http://elevensky.github.io/2015/02/25/nodejs%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"/>
    <id>http://elevensky.github.io/2015/02/25/nodejs基础教程/</id>
    <published>2015-02-25T04:48:54.000Z</published>
    <updated>2015-02-25T05:00:32.000Z</updated>
    <content type="html"><![CDATA[<h2 id="简介">简介</h2>
<p>Node.js是JavaScript在服务器端的一个运行环境，也是一个工具库，用来与服务器端其他软件互动。它的JavaScript解释器，采用了Google公司的V8引擎。</p>
<h3 id="安装与更新">安装与更新</h3>
<p>访问官方网站<a href="http://nodejs.org" target="_blank" rel="external">nodejs.org</a>了解安装细节。</p>
<p>安装完成以后，运行下面的命令，查看是否能正常运行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">node --version</div><div class="line">// 或者</div><div class="line">node -v</div></pre></td></tr></table></figure>

<p>更新node.js版本，可以通过node.js的n模块完成。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">sudo</span> npm install n -g</div><div class="line"><span class="built_in">sudo</span> n stable</div></pre></td></tr></table></figure>

<p>上面代码通过n模块，将node.js更新为最新发布的稳定版。</p>
<p>n模块也可以指定安装的版本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">sudo</span> n <span class="number">0.8</span>.<span class="number">21</span></div></pre></td></tr></table></figure>

<h3 id="版本管理工具nvm">版本管理工具nvm</h3>
<p>如果想在同一台机器，同时运行多个版本的node.js，就需要用到版本管理工具nvm。</p>
<p>首先，需要安装nvm。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">git clone https://github.com/creationix/nvm.git ~/.nvm</div></pre></td></tr></table></figure>

<p>然后使用下面的命令，激活nvm。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">source</span> ~/.nvm/nvm.sh</div></pre></td></tr></table></figure>

<p>上面这条命令，每次使用nvm前都要输入，建议将其加入~/.bashrc文件（假定你所使用的shell是bash）。</p>
<p>激活nvm之后，就可以安装指定版本的node.js。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">nvm install <span class="number">0.10</span></div></pre></td></tr></table></figure>

<p>上面这条命令，安装最新的v0.10.x版本的node.js。</p>
<p>安装后，就可以指定使用该版本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">nvm use <span class="number">0.10</span></div></pre></td></tr></table></figure>

<p>或者，直接进入该版本的REPL环境。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">nvm run <span class="number">0.10</span></div></pre></td></tr></table></figure>

<p>如果在项目根目录下新建一个.nvmrc文件，将版本号写入其中，则nvm use命令就不再需要附加版本号。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">nvm use</div></pre></td></tr></table></figure>

<p>ls命令用于查看本地所安装的版本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">nvm ls</div></pre></td></tr></table></figure>

<p>ls-remote命令用于查看服务器上所有可供安装的版本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">nvm ls-remote</div></pre></td></tr></table></figure>

<p>如果要退出已经激活的nvm，使用deactivate命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">nvm deactivate</div></pre></td></tr></table></figure>

<h3 id="基本用法">基本用法</h3>
<p>安装完成后，运行node.js程序，就是使用node命令读取JavaScript脚本。</p>
<p>假定当前目录有一个demo.js的脚本文件，运行时这样写。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">node demo</div><div class="line"></div><div class="line">// 或者</div><div class="line"></div><div class="line">node demo.js</div></pre></td></tr></table></figure>

<h3 id="REPL环境">REPL环境</h3>
<p>在命令行键入node命令，后面没有文件名，就进入一个Node.js的REPL环境（Read–eval–print loop，”读取-求值-输出”循环），可以直接运行各种JavaScript命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">node</div><div class="line">&gt; <span class="number">1</span>+<span class="number">1</span></div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure>

<p>如果使用参数 —use_strict，则REPL将在严格模式下运行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">node --use_strict</div></pre></td></tr></table></figure>

<p>这个REPL是Node.js与用户互动的shell，各种基本的shell功能都可以在里面使用，比如使用上下方向键遍历曾经使用过的命令。特殊变量下划线（_）表示上一个命令的返回结果。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&gt; <span class="number">1</span>+<span class="number">1</span></div><div class="line"><span class="number">2</span></div><div class="line">&gt; _+<span class="number">1</span></div><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure>

<p>在REPL中，如果运行一个表达式，会直接在命令行返回结果，如果运行一条语句则不会，因为它没有返回值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&gt; x = <span class="number">1</span></div><div class="line"><span class="number">1</span></div><div class="line">&gt; var x = <span class="number">1</span></div></pre></td></tr></table></figure>

<p>上面代码的第二条命令，没有显示任何结果。因为这是一条语句，不是表达式，所以没有返回值。</p>
<h3 id="异步操作">异步操作</h3>
<p>Node采用V8引擎处理JavaScript脚本，最大特点就是单线程运行，一次只能运行一个任务。这导致Node大量采用异步操作（asynchronous opertion），即任务不是马上执行，而是插在任务队列的尾部，等到前面的任务运行完后再执行。</p>
<p>由于这种特性，某一个任务的后续操作，往往采用回调函数（callback）的形式进行定义。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> isTrue = <span class="function"><span class="keyword">function</span><span class="params">(value, callback)</span> </span>{</div><div class="line">  <span class="keyword">if</span> (value === <span class="literal">true</span>) {</div><div class="line">    callback(<span class="literal">null</span>, <span class="string">"Value was true."</span>);</div><div class="line">  }</div><div class="line">  <span class="keyword">else</span> {</div><div class="line">    callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Value is not true!"</span>));</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面代码就把进一步的处理，交给回调函数callback。约定俗成，callback的位置总是最后一个参数。值得注意的是，callback的格式也有约定。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> callback = <span class="function"><span class="keyword">function</span> <span class="params">(error, value)</span> </span>{</div><div class="line">  <span class="keyword">if</span> (error) {</div><div class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(error);</div><div class="line">  }</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>callback的第一个参数是一个Error对象，第二个参数才是真正的数据。如果没有发生错误，第一个参数就传入null。这种写法有一个很大的好处，就是说只要判断回调函数的第一个参数，就知道有没有出错，如果不是null，就肯定出错了。</p>
<h3 id="全局对象和全局变量">全局对象和全局变量</h3>
<p>Node提供以下一些全局对象，它们是所有模块都可以调用的。</p>
<ul>
<li><strong>global</strong>：表示Node所在的全局环境，类似于浏览器中的window对象。</li>
<li><strong>process</strong>：指向Node内置的process模块，允许开发者与当前进程互动。</li>
<li><strong>console</strong>：指向Node内置的console模块，提供命令行环境中的标准输入、标准输出功能。</li>
</ul>
<p>全局函数：</p>
<ul>
<li><strong>定时器函数</strong>：共有4个，分别是setTimeout(), clearTimeout(), setInterval(), clearInterval()。</li>
<li><strong>require</strong>：用于加载模块。</li>
</ul>
<p>全局变量：</p>
<ul>
<li><strong>_filename</strong>：指向当前运行的脚本文件名。</li>
<li><strong>_dirname</strong>：指向当前运行的脚本所在的目录。</li>
</ul>
<p>除此之外，还有一些对象实际上是模块内部的局部变量，指向的对象根据模块不同而不同，但是所有模块都适用，可以看作是伪全局变量，主要为module, module.exports, exports等。</p>
<p>module变量指代当前模块。module.exports变量表示当前模块对外输出的接口，其他文件加载该模块，实际上就是读取module.exports变量。</p>
<ul>
<li>module.id 模块的识别符，通常是模块的文件名。</li>
<li>module.filename 模块的文件名。</li>
<li>module.loaded 返回一个布尔值，表示模块是否已经完成加载。</li>
<li>module.parent 返回使用该模块的模块。</li>
<li>module.children 返回一个数组，表示该模块要用到的其他模块。</li>
</ul>
<p>这里需要特别指出的是，exports变量实际上是一个指向module.exports对象的链接，等同在每个模块头部，有一行这样的命令。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> exports = <span class="built_in">module</span>.exports;</div></pre></td></tr></table></figure>

<p>这造成的结果是，在对外输出模块接口时，可以向exports对象添加方法，但是不能直接将exports变量指向一个函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">exports = <span class="function"><span class="keyword">function</span> <span class="params">(x)</span></span>{ <span class="built_in">console</span>.log(x);};</div></pre></td></tr></table></figure>

<p>上面这样的写法是无效的，因为它切断了exports与module.exports之间的链接。但是，下面这样写是可以的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">exports.area = <span class="function"><span class="keyword">function</span> <span class="params">(r)</span> </span>{</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.PI * r * r;</div><div class="line">};</div><div class="line"></div><div class="line">exports.circumference = <span class="function"><span class="keyword">function</span> <span class="params">(r)</span> </span>{</div><div class="line">  <span class="keyword">return</span> <span class="number">2</span> * <span class="built_in">Math</span>.PI * r;</div><div class="line">};</div></pre></td></tr></table></figure>

<p>如果你觉得，exports与module.exports之间的区别很难分清，一个简单的处理方法，就是放弃使用exports，只使用module.exports。</p>
<h2 id="模块化结构">模块化结构</h2>
<h3 id="概述">概述</h3>
<p>Node.js采用模块化结构，按照<a href="http://wiki.commonjs.org/wiki/CommonJS" target="_blank" rel="external">CommonJS规范</a>定义和使用模块。模块与文件是一一对应关系，即加载一个模块，实际上就是加载对应的一个模块文件。</p>
<p>require方法用于指定加载模块。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> circle = <span class="built_in">require</span>(<span class="string">'./circle.js'</span>);</div></pre></td></tr></table></figure>

<p>上面代码表明，从当前目录下的circle.js文件，加载circle模块。因为require方法默认加载的就是js文件，因此可以把js后缀名省略。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> circle = <span class="built_in">require</span>(<span class="string">'./circle'</span>);</div></pre></td></tr></table></figure>

<p>require方法的参数是模块文件的名字。它分成两种情况，第一种情况是参数中含有文件路径（比如上例），这时路径是相对于当前脚本所在的目录，第二种情况是参数中不含有文件路径（比如下例）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> bar = <span class="built_in">require</span>(<span class="string">'bar'</span>);</div></pre></td></tr></table></figure>

<p>如果require方法的参数不带有路径，则node.js依次按照以下顺序，去寻找模块文件。</p>
<p>node.js依次到下面的目录，去寻找bar模块。</p>
<ul>
<li>./node_modules/bar</li>
<li>../node_modules/bar</li>
<li>../../node_modules/bar</li>
<li>/node_modules/bar</li>
</ul>
<p>可以看到，如果没有指明模块所在位置，Node会依次从当前目录向上，一级级在node_modules子目录下寻找模块。如果没有找到该模块，会抛出一个错误。这样做的好处是，不同的项目可以在自己的目录中，安装同一个模块的不同版本，而不会发生版本冲突。</p>
<p>有时候，一个模块本身就是一个目录，目录中包含多个文件。这时候，Node在package.json文件中，寻找main属性所指明的模块入口文件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">{</div><div class="line">  <span class="string">"name"</span> : <span class="string">"bar"</span>,</div><div class="line">  <span class="string">"main"</span> : <span class="string">"./lib/bar.js"</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面代码中，模块的启动文件为lib子目录下的bar.js。当使用require(‘bar’)命令加载该模块时，实际上加载的是<code>bar/lib/some-library.js</code>文件。下面写法会起到同样效果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> bar = <span class="built_in">require</span>(<span class="string">'bar/lib/bar.js'</span>)</div></pre></td></tr></table></figure>

<p>如果模块目录中没有package.json文件，node.js会尝试在模块目录中寻找index.js或index.node文件进行加载。</p>
<p>模块一旦被加载以后，就会被系统缓存。如果第二次还加载该模块，则会返回缓存中的版本，这意味着模块实际上只会执行一次。如果希望模块执行多次，则可以让模块返回一个函数，然后多次调用该函数。</p>
<h3 id="核心模块">核心模块</h3>
<p>如果只是在服务器运行JavaScript代码，用处并不大，因为服务器脚本语言已经有很多种了。Node.js的用处在于，它本身还提供了一系列功能模块，与操作系统互动。这些核心的功能模块，不用安装就可以使用，下面是它们的清单。</p>
<ul>
<li><strong>http</strong>：提供HTTP服务器功能。</li>
<li><strong>url</strong>：解析URL。</li>
<li><strong>fs</strong>：与文件系统交互。</li>
<li><strong>querystring</strong>：解析URL的查询字符串。</li>
<li><strong>child_process</strong>：新建子进程。</li>
<li><strong>util</strong>：提供一系列实用小工具。</li>
<li><strong>path</strong>：处理文件路径。</li>
<li><strong>crypto</strong>：提供加密和解密功能，基本上是对OpenSSL的包装。</li>
</ul>
<p>除了使用核心模块，还可以使用第三方模块，以及自定义模块。</p>
<h3 id="自定义模块">自定义模块</h3>
<p>Node模块采用CommonJS规范。只要符合这个规范，就可以自定义模块。</p>
<p>下面是一个最简单的模块，假定新建一个foo.js文件，写入以下内容。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// foo.js</span></div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span><span class="params">(x)</span> </span>{</div><div class="line">    <span class="built_in">console</span>.log(x);</div><div class="line">};</div></pre></td></tr></table></figure>

<p>上面代码就是一个模块，它通过module.exports变量，对外输出一个方法。</p>
<p>这个模块的使用方法如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// index.js</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> m = <span class="built_in">require</span>(<span class="string">'./foo'</span>);</div><div class="line"></div><div class="line">m(<span class="string">"这是自定义模块"</span>);</div></pre></td></tr></table></figure>

<p>上面代码通过require命令加载模块文件foo.js（后缀名省略），将模块的对外接口输出到变量m，然后调用m。这时，在命令行下运行index.js，屏幕上就会输出“这是自定义模块”。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">$ node index</div><div class="line">这是自定义模块</div></pre></td></tr></table></figure>

<p>module变量是整个模块文件的顶层变量，它的exports属性就是模块向外输出的接口。如果直接输出一个函数（就像上面的foo.js），那么调用模块就是调用一个函数。但是，模块也可以输出一个对象。下面对foo.js进行改写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// foo.js</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> out = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">p</span><span class="params">(string)</span> </span>{</div><div class="line">  <span class="built_in">console</span>.log(string);</div><div class="line">}</div><div class="line"></div><div class="line">out.print = p;</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = out;</div></pre></td></tr></table></figure>

<p>上面的代码表示模块输出out对象，该对象有一个print属性，指向一个函数。下面是这个模块的使用方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// index.js</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> m = <span class="built_in">require</span>(<span class="string">'./foo'</span>);</div><div class="line"></div><div class="line">m.print(<span class="string">"这是自定义模块"</span>);</div></pre></td></tr></table></figure>

<p>上面代码表示，由于具体的方法定义在模块的print属性上，所以必须显式调用print属性。</p>
<h2 id="http模块">http模块</h2>
<h3 id="基本用法-1">基本用法</h3>
<p>http模块主要用于搭建HTTP服务。使用Node.js搭建HTTP服务器非常简单。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"></div><div class="line">http.createServer(<span class="function"><span class="keyword">function</span> <span class="params">(request, response)</span></span>{</div><div class="line">  response.writeHead(<span class="number">200</span>, {<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>});</div><div class="line">  response.end(<span class="string">'Hello World\n'</span>);</div><div class="line">}).listen(<span class="number">8080</span>, <span class="string">"127.0.0.1"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Server running on port 8080.'</span>);</div></pre></td></tr></table></figure>

<p>上面代码第一行<code>var http = require(&quot;http&quot;)</code>，表示加载http模块。然后，调用http模块的createServer方法，创造一个服务器实例，将它赋给变量http。</p>
<p>ceateServer方法接受一个函数作为参数，该函数的request参数是一个对象，表示客户端的HTTP请求；response参数也是一个对象，表示服务器端的HTTP回应。response.writeHead方法表示，服务器端回应一个HTTP头信息；response.end方法表示，服务器端回应的具体内容，以及回应完成后关闭本次对话。最后的listen(8080)表示启动服务器实例，监听本机的8080端口。</p>
<p>将上面这几行代码保存成文件app.js，然后用node调用这个文件，服务器就开始运行了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">$ node app.js</div></pre></td></tr></table></figure>

<p>这时命令行窗口将显示一行提示“Server running at port 8080.”。打开浏览器，访问<a href="http://localhost:8080，网页显示“Hello" target="_blank" rel="external">http://localhost:8080，网页显示“Hello</a> world!”。</p>
<p>上面的例子是当场生成网页，也可以事前写好网页，存在文件中，然后利用fs模块读取网页文件，将其返回。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"></div><div class="line">http.createServer(<span class="function"><span class="keyword">function</span> <span class="params">(request, response)</span></span>{</div><div class="line">  fs.readFile(<span class="string">'data.txt'</span>, <span class="function"><span class="keyword">function</span> <span class="title">readData</span><span class="params">(err, data)</span> </span>{</div><div class="line">    response.writeHead(<span class="number">200</span>, {<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>});</div><div class="line">    response.end(data);</div><div class="line">  });</div><div class="line">}).listen(<span class="number">8080</span>, <span class="string">"127.0.0.1"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Server running on port 8080.'</span>);</div></pre></td></tr></table></figure>

<p>下面的修改则是根据不同网址的请求，显示不同的内容，已经相当于做出一个网站的雏形了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</div><div class="line"></div><div class="line">http.createServer(<span class="function"><span class="keyword">function</span><span class="params">(req, res)</span> </span>{</div><div class="line"></div><div class="line">  <span class="comment">// 主页</span></div><div class="line">  <span class="keyword">if</span> (req.url == <span class="string">"/"</span>) {</div><div class="line">    res.writeHead(<span class="number">200</span>, { <span class="string">"Content-Type"</span>: <span class="string">"text/html"</span> });</div><div class="line">    res.end(<span class="string">"Welcome to the homepage!"</span>);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// About页面</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (req.url == <span class="string">"/about"</span>) {</div><div class="line">    res.writeHead(<span class="number">200</span>, { <span class="string">"Content-Type"</span>: <span class="string">"text/html"</span> });</div><div class="line">    res.end(<span class="string">"Welcome to the about page!"</span>);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// 404错误</span></div><div class="line">  <span class="keyword">else</span> {</div><div class="line">    res.writeHead(<span class="number">404</span>, { <span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span> });</div><div class="line">    res.end(<span class="string">"404 error! File not found."</span>);</div><div class="line">  }</div><div class="line"></div><div class="line">}).listen(<span class="number">8080</span>, <span class="string">"localhost"</span>);</div></pre></td></tr></table></figure>

<p>回调函数的req（request）对象，拥有以下属性。</p>
<ul>
<li>url：发出请求的网址。</li>
<li>method：HTTP请求的方法。</li>
<li>headers：HTTP请求的所有HTTP头信息。</li>
</ul>
<h3 id="处理POST请求">处理POST请求</h3>
<p>当客户端采用POST方法发送数据时，服务器端可以对data和end两个事件，设立监听函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"></div><div class="line">http.createServer(<span class="function"><span class="keyword">function</span> <span class="params">(req, res)</span> </span>{</div><div class="line">  <span class="keyword">var</span> content = <span class="string">""</span>;</div><div class="line"></div><div class="line">  req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(chunk)</span> </span>{</div><div class="line">    content += chunk;</div><div class="line">  });</div><div class="line"></div><div class="line">  req.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">    res.writeHead(<span class="number">200</span>, {<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>});</div><div class="line">  res.write(<span class="string">"You've sent: "</span> + content);</div><div class="line">    res.end();</div><div class="line">  });</div><div class="line"></div><div class="line">}).listen(<span class="number">8080</span>);</div></pre></td></tr></table></figure>

<p>data事件会在数据接收过程中，每收到一段数据就触发一次，接收到的数据被传入回调函数。end事件则是在所有数据接收完成后触发。</p>
<p>对上面代码稍加修改，就可以做出文件上传的功能。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="pi"></span></div><div class="line">"use strict";</div><div class="line"></div><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="keyword">var</span> destinationFile, fileSize, uploadedBytes;</div><div class="line"></div><div class="line">http.createServer(<span class="function"><span class="keyword">function</span> <span class="params">(request, response)</span> </span>{</div><div class="line">  response.writeHead(<span class="number">200</span>);</div><div class="line">  destinationFile = fs.createWriteStream(<span class="string">"destination.md"</span>);</div><div class="line">  request.pipe(destinationFile);</div><div class="line">  fileSize = request.headers[<span class="string">'content-length'</span>];</div><div class="line">  uploadedBytes = <span class="number">0</span>;</div><div class="line"></div><div class="line">  request.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(d)</span> </span>{</div><div class="line">    uploadedBytes += d.length;</div><div class="line">    <span class="keyword">var</span> p = (uploadedBytes / fileSize) * <span class="number">100</span>;</div><div class="line">    response.write(<span class="string">"Uploading "</span> + <span class="built_in">parseInt</span>(p, <span class="number">0</span>) + <span class="string">" %\n"</span>);</div><div class="line">  });</div><div class="line"></div><div class="line">  request.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">    response.end(<span class="string">"File Upload Complete"</span>);</div><div class="line">  });</div><div class="line">}).listen(<span class="number">3030</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"server started"</span>);</div><div class="line">});</div></pre></td></tr></table></figure>

<h3 id="发出请求：request方法">发出请求：request方法</h3>
<p>request方法用于发出HTTP请求。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"></div><div class="line"><span class="comment">//The url we want is: 'www.random.org/integers/?num=1&min=1&max=10&col=1&base=10&format=plain&rnd=new'</span></div><div class="line"><span class="keyword">var</span> options = {</div><div class="line">  host: <span class="string">'www.random.org'</span>,</div><div class="line">  path: <span class="string">'/integers/?num=1&min=1&max=10&col=1&base=10&format=plain&rnd=new'</span></div><div class="line">};</div><div class="line"></div><div class="line">callback = <span class="function"><span class="keyword">function</span><span class="params">(response)</span> </span>{</div><div class="line">  <span class="keyword">var</span> str = <span class="string">''</span>;</div><div class="line"></div><div class="line">  <span class="comment">//another chunk of data has been recieved, so append it to `str`</span></div><div class="line">  response.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(chunk)</span> </span>{</div><div class="line">    str += chunk;</div><div class="line">  });</div><div class="line"></div><div class="line">  <span class="comment">//the whole response has been recieved, so we just print it out here</span></div><div class="line">  response.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">    <span class="built_in">console</span>.log(str);</div><div class="line">  });</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> req = http.request(options, callback);</div><div class="line"></div><div class="line">req.write(<span class="string">"hello world!"</span>);</div><div class="line">req.end();</div></pre></td></tr></table></figure>

<p>request对象的第一个参数是options对象，用于指定请求的域名和路径，第二个参数是请求完成后的回调函数。</p>
<p>如果使用POST方法发出请求，只需在options对象中设定即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> options = {</div><div class="line">  host: <span class="string">'www.example.com'</span>,</div><div class="line">  path: <span class="string">'/'</span>,</div><div class="line">  port: <span class="string">'80'</span>,</div><div class="line">  method: <span class="string">'POST'</span></div><div class="line">};</div></pre></td></tr></table></figure>

<p>指定HTTP头信息，也是在options对象中设定。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> options = {</div><div class="line">  headers: {<span class="string">'custom'</span>: <span class="string">'Custom Header Demo works'</span>}</div><div class="line">};</div></pre></td></tr></table></figure>

<h3 id="搭建HTTPs服务器">搭建HTTPs服务器</h3>
<p>搭建HTTPs服务器需要有SSL证书。对于向公众提供服务的网站，SSL证书需要向证书颁发机构购买；对于自用的网站，可以自制。</p>
<p>自制SSL证书需要OpenSSL，具体命令如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">openssl genrsa -out key.pem</div><div class="line">openssl req -new -key key.pem -out csr.pem</div><div class="line">openssl x509 -req -days <span class="number">9999</span> -in csr.pem -signkey key.pem -out cert.pem</div><div class="line">rm csr.pem</div></pre></td></tr></table></figure>

<p>上面的命令生成两个文件：ert.pem（证书文件）和 key.pem（私钥文件）。有了这两个文件，就可以运行HTTPs服务器了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> https = <span class="built_in">require</span>(<span class="string">'https'</span>);</div><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> options = {</div><div class="line">  key: fs.readFileSync(<span class="string">'key.pem'</span>),</div><div class="line">  cert: fs.readFileSync(<span class="string">'cert.pem'</span>)</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = https.createServer(options, <span class="function"><span class="keyword">function</span> <span class="params">(req, res)</span> </span>{</div><div class="line">  res.writeHead(<span class="number">200</span>);</div><div class="line">  res.end(<span class="string">"hello world\n"</span>);</div><div class="line">}).listen(<span class="number">8000</span>);</div></pre></td></tr></table></figure>

<p>上面代码显示，HTTPs服务器与HTTP服务器的最大区别，就是createServer方法多了一个options参数。运行以后，就可以测试是否能够正常访问。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">curl -k https://localhost:<span class="number">8000</span></div></pre></td></tr></table></figure>

<h2 id="Buffer对象">Buffer对象</h2>
<p>Buffer对象是Node.js用来处理二进制数据的一个接口。它是一个构造函数，它的实例代表了V8引擎分配的一段内存。</p>
<p>Buffer对象可以用new命令生成一个实例，它的参数就是存入内存的数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> hello = <span class="keyword">new</span> Buffer(<span class="string">'Hello'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(hello);</div><div class="line"><span class="comment">// &lt;Buffer 48 65 6c 6c 6f&gt;</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(hello.toString());</div><div class="line"><span class="comment">// "Hello"</span></div></pre></td></tr></table></figure>

<p>上面代码表示，hello是一个Buffer，内容为储存在内存中的五个字符的二进制数据，使用toString方法可以看到对应的字符串。</p>
<p>toString方法可以只返回指定位置内存的内容，它的第二个参数表示起始位置，第三个参数表示终止位置，两者都是从0开始计算。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> buf = <span class="keyword">new</span> Buffer(<span class="string">'just some data'</span>);</div><div class="line"><span class="built_in">console</span>.log(buf.toString(<span class="string">'ascii'</span>, <span class="number">4</span>, <span class="number">9</span>));</div><div class="line"><span class="comment">// "some"</span></div></pre></td></tr></table></figure>

<p>除了使用字符串参数，生成Buffer实例，还可以使用十六进制数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> hello = <span class="keyword">new</span> Buffer([<span class="number">0x48</span>, <span class="number">0x65</span>, <span class="number">0x6c</span>, <span class="number">0x6c</span>, <span class="number">0x6f</span>]);</div></pre></td></tr></table></figure>

<p>构造函数Buffer的参数，如果是一个数值，就表示所生成的实例占据内存多少个字节。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> buf = <span class="keyword">new</span> Buffer(<span class="number">5</span>);</div><div class="line">buf.write(<span class="string">'He'</span>);</div><div class="line">buf.write(<span class="string">'l'</span>, <span class="number">2</span>);</div><div class="line">buf.write(<span class="string">'lo'</span>, <span class="number">3</span>);</div><div class="line"><span class="built_in">console</span>.log(buf.toString());</div><div class="line"><span class="comment">// "Hello"</span></div></pre></td></tr></table></figure>

<p>Buffer实例的write方法，可以向所指定的内存写入数据。它的第一个参数是所写入的内容，第二个参数是所写入的起始位置（从0开始）。所以，上面代码最后写入内存的内容是Hello。</p>
<p>Buffer实例的length属性，返回Buffer实例所占据的内存长度。如果想知道一个字符串所占据的字节长度，可以将其传入Buffer.byteLength方法。</p>
<p>Buffer实例的slice方法，返回一个按照指定位置、从原对象切割出来的Buffer实例。它的两个参数分别为切割的起始位置和终止位置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> buf = <span class="keyword">new</span> Buffer(<span class="string">'just some data'</span>);</div><div class="line"><span class="keyword">var</span> chunk = buf.slice(<span class="number">4</span>, <span class="number">9</span>);</div><div class="line"><span class="built_in">console</span>.log(chunk.toString());</div><div class="line"><span class="comment">// "some"</span></div></pre></td></tr></table></figure>

<h2 id="cluster模块">cluster模块</h2>
<p>Node.js默认单进程运行，对于多核CPU的计算机来说，这样做效率很低，因为只有一个核在运行，其他核都在闲置。cluster模块就是为了解决这个问题而提出的。</p>
<p>cluster模块允许设立一个主进程和若干个worker进程，由主进程监控和协调worker进程的运行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> cluster = <span class="built_in">require</span>(<span class="string">'cluster'</span>);</div><div class="line"><span class="keyword">var</span> os = <span class="built_in">require</span>(<span class="string">'os'</span>);</div><div class="line"></div><div class="line"><span class="keyword">if</span> (cluster.isMaster){</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, n = os.cpus().length; i &lt; n; i += <span class="number">1</span>){</div><div class="line">        cluster.fork();</div><div class="line">    }</div><div class="line">}<span class="keyword">else</span>{</div><div class="line">    http.createServer(<span class="function"><span class="keyword">function</span><span class="params">(req, res)</span> </span>{</div><div class="line">      res.writeHead(<span class="number">200</span>);</div><div class="line">      res.end(<span class="string">"hello world\n"</span>);</div><div class="line">    }).listen(<span class="number">8000</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面代码先判断当前进程是否为主进程（cluster.isMaster），如果是的，就按照CPU的核数，新建若干个worker进程；如果不是，说明当前进程是worker进程，则在该进程启动一个服务器程序。</p>
<h2 id="异常处理">异常处理</h2>
<p>Node是单线程运行环境，一旦抛出的异常没有被捕获，就会引起整个进程的崩溃。所以，Node的异常处理对于保证系统的稳定运行非常重要。</p>
<h3 id="try…catch结构">try…catch结构</h3>
<p>最常用的捕获异常的方式，就是使用try…catch结构。但是，这个结构无法捕获异步运行的代码抛出的异常。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">try</span> {</div><div class="line">    process.nextTick(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"error"</span>);</div><div class="line">    });</div><div class="line">} <span class="keyword">catch</span> (err) {</div><div class="line">    <span class="comment">//can not catch it</span></div><div class="line">    <span class="built_in">console</span>.log(err);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">try</span> {</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"error"</span>);</div><div class="line">    },<span class="number">1</span>)</div><div class="line">} <span class="keyword">catch</span> (err) {</div><div class="line">    <span class="comment">//can not catch it</span></div><div class="line">    <span class="built_in">console</span>.log(err);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面代码抛出的两个异常，都无法被catch代码块捕获。</p>
<h3 id="uncaughtException事件">uncaughtException事件</h3>
<p>当一个异常未被捕获，就会触发uncaughtException事件，可以对这个事件注册回调函数，从而捕获异常。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">process.on(<span class="string">'uncaughtException'</span>, <span class="function"><span class="keyword">function</span><span class="params">(err)</span> </span>{</div><div class="line">    <span class="built_in">console</span>.error(<span class="string">'Error caught in uncaughtException event:'</span>, err);</div><div class="line">});</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">try</span> {</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"error"</span>);</div><div class="line">    },<span class="number">1</span>)</div><div class="line">} <span class="keyword">catch</span> (err) {</div><div class="line">    <span class="comment">//can not catch it</span></div><div class="line">    <span class="built_in">console</span>.log(err);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>只要给uncaughtException配置了回调，Node进程不会异常退出，但异常发生的上下文已经丢失，无法给出异常发生的详细信息。而且，异常可能导致Node不能正常进行内存回收，出现内存泄露。所以，当uncaughtException触发后，最好记录错误日志，然后结束Node进程。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">process.on(<span class="string">'uncaughtException'</span>, <span class="function"><span class="keyword">function</span><span class="params">(err)</span> </span>{</div><div class="line">  logger(err);</div><div class="line">  process.exit(<span class="number">1</span>);</div><div class="line">});</div></pre></td></tr></table></figure>

<h3 id="正确的编码习惯">正确的编码习惯</h3>
<p>由于异步中的异常无法被外部捕获，所以异常应该作为第一个参数传递给回调函数，Node的编码规则就是这么规定的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">fs.readFile(<span class="string">'/t.txt'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(err, data)</span> </span>{</div><div class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</div><div class="line">  <span class="built_in">console</span>.log(data);</div><div class="line">});</div></pre></td></tr></table></figure>

<h2 id="命令行脚本">命令行脚本</h2>
<p>node脚本可以作为命令行脚本使用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ node foo.js</div></pre></td></tr></table></figure>

<p>上面代码执行了foo.js脚本文件。</p>
<p>foo.js文件的第一行，如果加入了解释器的位置，就可以将其作为命令行工具直接调用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env node</span></div></pre></td></tr></table></figure>

<p>调用前，需更改文件的执行权限。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ chmod u+x myscript.js</div><div class="line">$ ./foo.js arg1 arg2 ...</div></pre></td></tr></table></figure>

<p>作为命令行脚本时，<code>console.log</code>用于输出内容到标准输出，<code>process.stdin</code>用于读取标准输入，<code>child_process.exec()</code>用于执行一个shell命令。</p>
<h2 id="转载">转载</h2>
<ul>
<li>阮一峰个人博客, <a href="http://javascript.ruanyifeng.com/nodejs/basic.html" target="_blank" rel="external">What is Node.js?</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="简介">简介</h2>
<p>Node.js是JavaScript在服务器端的一个运行环境，也是一个工具库，用来与服务器端其他软件互动。它的JavaScript解释器，采用了Google公司的V8引擎。</p>
<h3 id="安装与更新">安装与更新</h3>
]]>
    </summary>
    
      <category term="nodejs" scheme="http://elevensky.github.io/tags/nodejs/"/>
    
      <category term="frontend" scheme="http://elevensky.github.io/categories/frontend/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[你是船长，你必须在黑暗中发出微光！]]></title>
    <link href="http://elevensky.github.io/2015/02/22/%E4%BD%A0%E6%98%AF%E8%88%B9%E9%95%BF/"/>
    <id>http://elevensky.github.io/2015/02/22/你是船长/</id>
    <published>2015-02-22T14:52:06.000Z</published>
    <updated>2015-02-25T06:58:47.000Z</updated>
    <content type="html"><![CDATA[<h2 id="创业者是与生俱来孤独的。那种焦灼和无助感，不亲身体会，不会真切感受到。">创业者是与生俱来孤独的。那种焦灼和无助感，不亲身体会，不会真切感受到。</h2>
<p>我曾写过《任何一个老板都配得上极大的尊重》现在更觉得，多大的光环给他都是应得的。</p>
<p>他就像一个探险船的船长，无论旅途多么艰辛都必须走下去，扛住所有的风暴和心酸，等到了新大陆才故作轻松地和船员们说：你们看我早说过了，让我们一起分财宝吧！没多少人注意，他转过身去流下了热泪。所以，被业界公认“隐忍第一、不动如山”的李彦宏在百度上市那一刻也忍不住热泪盈眶！</p>
<p>“应聘者将参与极度危险的旅程：赴南极探险。薪酬微薄，需在苦寒、危机四伏并且数月不见天日的地段工作。不保证安全返航，如若成功，惟一可获得者仅有荣誉。”</p>
<p>这是一百年前（1914年）轰动整个英国的招聘启示，由被队友誉为“最伟大的领导者”、著名探险家沙克尔顿爵士亲笔撰写发布。他希望召集一批勇士，由伦敦出发前往南极探险，横穿南极洲。</p>
<p>结果，超过 5000位男人应征，仅27人入选，还有1人竟然偷渡加入了该旅行。为什么有这么多人甘愿冒极大风险去参加这一探险活动？因为他们都是好汉子、真男人。他们心里，有一股对理想不屈的火焰。沙克尔顿爵士的家族格言是“Fortitudine vincimus”（我们靠坚毅而成功）。这艘船，就叫“坚毅号”。</p>
<p>最后，他们成功了。每一个探险队员都是伟大的，船长更伟大。</p>
<p>“战争打到一塌糊涂的时候，真正的将军作用是什么？就是要在看不清的茫茫黑暗中，用自己发出微光，带着你的队伍前进！”这是克劳塞维茨在西方军事经典《战争论》中一句著名的话，也是任正非极为推崇的一句话。</p>
<p>你是创始人，你是船长，你必须在黑暗中发出微光并且永不放弃！</p>
<p>谨以此句，与所有创业者共勉。Never，Never，Never give up.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="创业者是与生俱来孤独的。那种焦灼和无助感，不亲身体会，不会真切感受到。">创业者是与生俱来孤独的。那种焦灼和无助感，不亲身体会，不会真切感受到。</h2>
<p>我曾写过《任何一个老板都配得上极大的尊重》现在更觉得，多大的光环给他都是应得的。</p>
<p>他就像]]>
    </summary>
    
      <category term="life" scheme="http://elevensky.github.io/categories/life/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Gulp: 任务自动管理工具]]></title>
    <link href="http://elevensky.github.io/2015/02/14/Gulp-%E4%BB%BB%E5%8A%A1%E8%87%AA%E5%8A%A8%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    <id>http://elevensky.github.io/2015/02/14/Gulp-任务自动管理工具/</id>
    <published>2015-02-14T14:22:19.000Z</published>
    <updated>2015-02-15T09:57:38.000Z</updated>
    <content type="html"><![CDATA[<h2 id="gulp介绍">gulp介绍</h2>
<p>Gulp与Grunt一样，也是一个自动任务运行器。它充分借鉴了Unix操作系统的管道（pipe）思想，很多人认为，在操作上，它要比Grunt简单。</p>
<p>Gulp是基于Node.js构建的，因此Gulp源文件和你用来定义任务的Gulp文件都被写进了JavaScript（或者CoffeeScript）里。前端开发工程师还可以用自己熟悉的语言来编写任务去lint JavaScript和CSS、解析模板以及在文件变动时编译LESS文件（当然这些只是一小部分例子）。</p>
<p>Gulp本身虽然不能完成很多任务，但它有大量插件可用，开发者可以访问插件页面或者在npm搜索gulpplugin就能看到。例如，有些插件可以用来执行<a href="https://www.npmjs.org/package/gulp-jshint/" target="_blank" rel="external">JSHint</a>、<a href="https://www.npmjs.org/package/gulp-coffee/" target="_blank" rel="external">编译CoffeeScript</a>，<a href="http://npmjs.org/package/gulp-mocha" target="_blank" rel="external">执行Mocha</a>测试，甚至更新版本号。</p>
<p>对比其他构建工具，比如<a href="http://gruntjs.com/" target="_blank" rel="external">Grunt</a>，以及最近流行的Broccoli，我相信Gulp会更胜一筹（请看后面的”Why Gulp?”部分），同时我汇总了一个使用Javascript编写的构建工具清单，可供大家参考。</p>
<p>Gulp是一个可以<a href="https://github.com/gulpjs/gulp/" target="_blank" rel="external">在GitHub上</a>找到的开源项目。</p>
<h2 id="安装">安装</h2>
<p>Gulp需要全局安装，然后再在项目的开发目录中安装为本地模块。先进入项目目录，运行下面的命令。</p>
<a id="more"></a>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">npm install -g gulp</div><div class="line"></div><div class="line">npm install --save-dev gulp</div></pre></td></tr></table></figure>

<h2 id="gulpfile-js">gulpfile.js</h2>
<p>项目根目录中的gulpfile.js，是Gulp的配置文件。它大概是下面的样子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</div><div class="line"></div><div class="line">gulp.task(<span class="string">'default'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">});</div></pre></td></tr></table></figure>

<p>下面就是一个典型的gulpfile.js文件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>),</div><div class="line">   uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);</div><div class="line"></div><div class="line">gulp.task(<span class="string">'minify'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">   gulp.src(<span class="string">'js/app.js'</span>)</div><div class="line">      .pipe(uglify())</div><div class="line">      .pipe(gulp.dest(<span class="string">'build'</span>))</div><div class="line">});</div></pre></td></tr></table></figure>

<p>上面代码中使用了gulp-uglify模块。在此之前，需要先安装这个模块。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">npm install --save-dev gulp-uglify</div></pre></td></tr></table></figure>

<p>gulpfile.js加载gulp和gulp-uglify模块之后，使用gulp模块的task方法指定任务。task方法有两个参数，第一个是任务名，第二个是任务函数。在任务函数中，使用gulp模块的src方法，指定所要处理的文件，然后使用pipe方法，将上一步的输出转为当前的输入，进行链式处理。</p>
<p>在上面代码中，使用两次pipe方法，也就是说做了两种处理。第一种处理是使用gulp-uglify模块，压缩源码；第二种处理是使用gulp模块的dest方法，将上一步的输出写入本地文件，这里是build.js（代码中省略了后缀名js）。<br><img src="http://p1.qhimg.com/t01759cebd478ca1a35.png" width="400px;"><br>从上面的例子中可以看到，gulp充分使用了“管道”思想，就是一个数据流（stream）：src方法读入文件产生数据流，dest方法将数据流写入文件，中间是一些中间步骤，每一步都对数据流进行一些处理。</p>
<p>下面是另一个数据流的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">gulp.task(<span class="string">'js'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">   <span class="keyword">return</span> gulp.src(<span class="string">'js/*.js'</span>)</div><div class="line">      .pipe(jshint())</div><div class="line">      .pipe(uglify())</div><div class="line">      .pipe(concat(<span class="string">'app.js'</span>))</div><div class="line">      .pipe(gulp.dest(<span class="string">'build'</span>));</div><div class="line">});</div></pre></td></tr></table></figure>

<p>上面代码使用pipe命令，分别进行jshint、uglify、concat三步处理。</p>
<h2 id="gulp-src()">gulp.src()</h2>
<p>gulp模块的src方法，用于产生数据流。它的参数表示所要处理的文件，一般有以下几种形式。</p>
<ul>
<li>js/app.js：指定确切的文件名。</li>
<li>js/*.js：某个目录所有后缀名为js的文件。</li>
<li>js/**/*.js：某个目录及其所有子目录中的所有后缀名为js的文件。</li>
<li>!js/app.js：除了js/app.js以外的所有文件。</li>
<li>*.+(js|css)：匹配项目根目录下，所有后缀名为js或css的文件。</li>
</ul>
<p>src方法的参数还可以是一个数组，用来指定多个成员。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">gulp.src([<span class="string">'js/**/*.js'</span>, <span class="string">'!js/**/*.min.js'</span>])</div></pre></td></tr></table></figure>

<h2 id="gulp-task()">gulp.task()</h2>
<p>gulp模块的task方法，用于定义具体的任务。它的第一个参数是任务名，第二个参数是任务函数。下面是一个非常简单的任务函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">gulp.task(<span class="string">'greet'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">   <span class="built_in">console</span>.log(<span class="string">'Hello world!'</span>);</div><div class="line">});</div></pre></td></tr></table></figure>

<p>task方法还可以指定按顺序运行的一组任务。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">gulp.task(<span class="string">'build'</span>, [<span class="string">'css'</span>, <span class="string">'js'</span>, <span class="string">'imgs'</span>]);</div></pre></td></tr></table></figure>

<p>上面代码先指定build任务，它按次序由css、js、imgs三个任务所组成。注意，由于每个任务都是异步调用，所以没有办法保证js任务的开始运行的时间，正是css任务运行结束。</p>
<p>如果希望各个任务严格按次序运行，可以把前一个任务写成后一个任务的依赖模块。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">gulp.task(<span class="string">'css'</span>, [<span class="string">'greet'</span>], <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">   <span class="comment">// Deal with CSS here</span></div><div class="line">});</div></pre></td></tr></table></figure>

<p>上面代码表明，css任务依赖greet任务，所以css一定会在greet运行完成后再运行。</p>
<p>如果一个任务的名字为default，就表明它是“默认任务”，在命令行直接输入gulp命令，就会运行该任务。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">gulp.task(<span class="string">'default'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">   <span class="comment">// Your default task</span></div><div class="line">});</div></pre></td></tr></table></figure>

<h2 id="gulp-watch()">gulp.watch()</h2>
<p>gulp模块的watch方法，用于指定需要监视的文件。一旦这些文件发生变动，就运行指定任务。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">gulp.task(<span class="string">'watch'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">   gulp.watch(<span class="string">'templates/*.tmpl.html'</span>, [<span class="string">'build'</span>]);</div><div class="line">});</div></pre></td></tr></table></figure>

<p>上面代码指定，一旦templates目录中的模板文件发生变化，就运行build任务。</p>
<p>watch方法也可以用回调函数，代替指定的任务。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">gulp.watch(<span class="string">'templates/*.tmpl.html'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(event)</span> </span>{</div><div class="line">   <span class="built_in">console</span>.log(<span class="string">'Event type: '</span> + event.type);</div><div class="line">   <span class="built_in">console</span>.log(<span class="string">'Event path: '</span> + event.path);</div><div class="line">});</div></pre></td></tr></table></figure>

<p>另一种写法是watch方法所监控的文件发生变化时（修改、增加、删除文件），会触发change事件。可以对change事件指定回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> watcher = gulp.watch(<span class="string">'templates/*.tmpl.html'</span>, [<span class="string">'build'</span>]);</div><div class="line"></div><div class="line">watcher.on(<span class="string">'change'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(event)</span> </span>{</div><div class="line">   <span class="built_in">console</span>.log(<span class="string">'Event type: '</span> + event.type);</div><div class="line">   <span class="built_in">console</span>.log(<span class="string">'Event path: '</span> + event.path);</div><div class="line">});</div></pre></td></tr></table></figure>

<p>除了change事件，watch方法还可能触发以下事件。</p>
<ul>
<li>end：回调函数运行完毕时触发。</li>
<li>error：发生错误时触发。</li>
<li>ready：当开始监听文件时触发。</li>
<li>nomatch：没有匹配的监听文件时触发。</li>
</ul>
<p>watcher对象还包含其他一些方法。</p>
<ul>
<li>watcher.end()：停止watcher对象，不会再调用任务或回调函数。</li>
<li>watcher.files()：返回watcher对象监视的文件。</li>
<li>watcher.add(glob)：增加所要监视的文件，它还可以附件第二个参数，表示回调函数。</li>
<li>watcher.remove(filepath)：从watcher对象中移走一个监视的文件。</li>
</ul>
<h2 id="gulp-load-plugins模块">gulp-load-plugins模块</h2>
<p>一般情况下，gulpfile.js中的模块需要一个个加载。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>),</div><div class="line">    jshint = <span class="built_in">require</span>(<span class="string">'gulp-jshint'</span>),</div><div class="line">    uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>),</div><div class="line">    concat = <span class="built_in">require</span>(<span class="string">'gulp-concat'</span>);</div><div class="line"></div><div class="line">gulp.task(<span class="string">'js'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">   <span class="keyword">return</span> gulp.src(<span class="string">'js/*.js'</span>)</div><div class="line">      .pipe(jshint())</div><div class="line">      .pipe(jshint.reporter(<span class="string">'default'</span>))</div><div class="line">      .pipe(uglify())</div><div class="line">      .pipe(concat(<span class="string">'app.js'</span>))</div><div class="line">      .pipe(gulp.dest(<span class="string">'build'</span>));</div><div class="line">});</div></pre></td></tr></table></figure>

<p>上面代码中，除了gulp模块以外，还加载另外三个模块。</p>
<p>这种一一加载的写法，比较麻烦。使用gulp-load-plugins模块，可以加载package.json文件中所有的gulp模块。上面的代码用gulp-load-plugins模块改写，就是下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>),</div><div class="line">    gulpLoadPlugins = <span class="built_in">require</span>(<span class="string">'gulp-load-plugins'</span>),</div><div class="line">    plugins = gulpLoadPlugins();</div><div class="line"></div><div class="line">gulp.task(<span class="string">'js'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">   <span class="keyword">return</span> gulp.src(<span class="string">'js/*.js'</span>)</div><div class="line">      .pipe(plugins.jshint())</div><div class="line">      .pipe(plugins.jshint.reporter(<span class="string">'default'</span>))</div><div class="line">      .pipe(plugins.uglify())</div><div class="line">      .pipe(plugins.concat(<span class="string">'app.js'</span>))</div><div class="line">      .pipe(gulp.dest(<span class="string">'build'</span>));</div><div class="line">});</div></pre></td></tr></table></figure>

<p>上面代码假设package.json文件包含以下内容。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">{</div><div class="line">   <span class="string">"devDependencies"</span>: {</div><div class="line">      <span class="string">"gulp-concat"</span>: <span class="string">"~2.2.0"</span>,</div><div class="line">      <span class="string">"gulp-uglify"</span>: <span class="string">"~0.2.1"</span>,</div><div class="line">      <span class="string">"gulp-jshint"</span>: <span class="string">"~1.5.1"</span>,</div><div class="line">      <span class="string">"gulp"</span>: <span class="string">"~3.5.6"</span></div><div class="line">   }</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="gulp-livereload模块">gulp-livereload模块</h2>
<p>gulp-livereload模块用于自动刷新浏览器，反映出源码的最新变化。它除了模块以外，还需要在浏览器中安装插件，用来配合源码变化。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>),</div><div class="line">    less = <span class="built_in">require</span>(<span class="string">'gulp-less'</span>),</div><div class="line">    livereload = <span class="built_in">require</span>(<span class="string">'gulp-livereload'</span>),</div><div class="line">    watch = <span class="built_in">require</span>(<span class="string">'gulp-watch'</span>);</div><div class="line"></div><div class="line">gulp.task(<span class="string">'less'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">   gulp.src(<span class="string">'less/*.less'</span>)</div><div class="line">      .pipe(watch())</div><div class="line">      .pipe(less())</div><div class="line">      .pipe(gulp.dest(<span class="string">'css'</span>))</div><div class="line">      .pipe(livereload());</div><div class="line">});</div></pre></td></tr></table></figure>

<p>上面代码监视less文件，一旦编译完成，就自动刷新浏览器。</p>
<h2 id="参考链接">参考链接</h2>
<ul>
<li><p>Callum Macrae, <a href="http://www.smashingmagazine.com/2014/06/11/building-with-gulp/" target="_blank" rel="external">Building With Gulp</a></p>
</li>
<li><p>w3ctech <a href="http://www.w3ctech.com/topic/134" target="_blank" rel="external">Gulp开发教程</a></p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="gulp介绍">gulp介绍</h2>
<p>Gulp与Grunt一样，也是一个自动任务运行器。它充分借鉴了Unix操作系统的管道（pipe）思想，很多人认为，在操作上，它要比Grunt简单。</p>
<p>Gulp是基于Node.js构建的，因此Gulp源文件和你用来定义任务的Gulp文件都被写进了JavaScript（或者CoffeeScript）里。前端开发工程师还可以用自己熟悉的语言来编写任务去lint JavaScript和CSS、解析模板以及在文件变动时编译LESS文件（当然这些只是一小部分例子）。</p>
<p>Gulp本身虽然不能完成很多任务，但它有大量插件可用，开发者可以访问插件页面或者在npm搜索gulpplugin就能看到。例如，有些插件可以用来执行<a href="https://www.npmjs.org/package/gulp-jshint/" target="_blank" rel="external">JSHint</a>、<a href="https://www.npmjs.org/package/gulp-coffee/" target="_blank" rel="external">编译CoffeeScript</a>，<a href="http://npmjs.org/package/gulp-mocha" target="_blank" rel="external">执行Mocha</a>测试，甚至更新版本号。</p>
<p>对比其他构建工具，比如<a href="http://gruntjs.com/" target="_blank" rel="external">Grunt</a>，以及最近流行的Broccoli，我相信Gulp会更胜一筹（请看后面的”Why Gulp?”部分），同时我汇总了一个使用Javascript编写的构建工具清单，可供大家参考。</p>
<p>Gulp是一个可以<a href="https://github.com/gulpjs/gulp/" target="_blank" rel="external">在GitHub上</a>找到的开源项目。</p>
<h2 id="安装">安装</h2>
<p>Gulp需要全局安装，然后再在项目的开发目录中安装为本地模块。先进入项目目录，运行下面的命令。</p>
]]>
    
    </summary>
    
      <category term="gulp" scheme="http://elevensky.github.io/tags/gulp/"/>
    
      <category term="前端" scheme="http://elevensky.github.io/categories/-categories-frontend/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[临沂苍山多肉大棚游]]></title>
    <link href="http://elevensky.github.io/2015/02/13/%E4%B8%B4%E6%B2%82%E8%8B%8D%E5%B1%B1%E5%A4%9A%E8%82%89%E5%A4%A7%E6%A3%9A%E6%B8%B8/"/>
    <id>http://elevensky.github.io/2015/02/13/临沂苍山多肉大棚游/</id>
    <published>2015-02-13T05:01:16.000Z</published>
    <updated>2015-02-15T09:57:58.000Z</updated>
    <content type="html"><![CDATA[<p>其实自从见到多肉以后，真的是非常非常喜欢的。<br>作为一个曾经混迹在一线城市的半吊子程序员，工作之外的生活就是程序员之间的搞基，单调乏味的个一逼。<br>作为一个连自己都养不好的人，养狗养猫咱们是一点个闲情雅致也没有。但是养点个植物还是很好的，至少你不用给动物一样天天他妈的伺候。<br>昨天去了我们大美临沂的多肉基地-苍山（兰陵）大柳树多肉大棚。<br>兰陵县月庄大柳树西200米。（大柳树是个标志，路口旁的一刻大柳树）<br>临沂多肉大棚详细路径：走206国道到兰陵汽车站，在汽车站前方第二个红绿灯处右拐，大约五公里，到北城医院就能看见大柳树，从大柳树处左拐进去大约半公里左侧<br>下面上图：</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>其实自从见到多肉以后，真的是非常非常喜欢的。<br>作为一个曾经混迹在一线城市的半吊子程序员，工作之外的生活就是程序员之间的搞基，单调乏味的个一逼。<br>作为一个连自己都养不好的人，养狗养猫咱们是一点个闲情雅致也没有。但是养点个植物还是很好的，至少你不用给动物一样天天他妈]]>
    </summary>
    
      <category term="多肉" scheme="http://elevensky.github.io/categories/-categories-duorou/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2014年技术战略]]></title>
    <link href="http://elevensky.github.io/2015/02/11/%E6%88%91%E7%9A%842014/"/>
    <id>http://elevensky.github.io/2015/02/11/我的2014/</id>
    <published>2015-02-11T06:06:35.000Z</published>
    <updated>2015-02-15T09:57:34.000Z</updated>
    <content type="html"><![CDATA[<p>2014年是很受伤的一年，我就不在这里诉苦了。</p>
<p>说说今年的一些计划，作为一个前端从业者，越来越感受到技术的紧迫性。<br>随着前端在整个行业领域的日益凸显，这个行业的技术无论从深度，广度上都在日益的重度加重当中。<br>作为在这个领域底层摸爬滚打的人，我深深感觉到自己的不足，甚至一度怀疑自己是否真的擅长做这个。<br>我一直以来都不是一个妄自菲薄和狂妄自大的人。走到今天，我已经深知自己是一个有自知之明的人。<br><a id="more"></a><br>虽然痛苦迷茫失落了2014年，但是毕竟自己一踏入职场便选择的这个行业。</p>
<p>今年初步需要掌握的一些技术</p>
<h3 id="javascript">javascript</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Nodejs+express+angularjs+mongodb</div><div class="line"></div><div class="line">glup工具的使用</div><div class="line"></div><div class="line">html5</div><div class="line"><span class="operator">less</span>,stylus</div></pre></td></tr></table></figure>

<p>哎自己智商捉急，从好几年开始气就想往js领域里深入，拖拖拉拉的前行这，现在这个行业趋势愈发让我感觉到这件事情迫在眉睫了。</p>
<p>一定要成功啊，fuck do it.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>2014年是很受伤的一年，我就不在这里诉苦了。</p>
<p>说说今年的一些计划，作为一个前端从业者，越来越感受到技术的紧迫性。<br>随着前端在整个行业领域的日益凸显，这个行业的技术无论从深度，广度上都在日益的重度加重当中。<br>作为在这个领域底层摸爬滚打的人，我深深感觉到自己的不足，甚至一度怀疑自己是否真的擅长做这个。<br>我一直以来都不是一个妄自菲薄和狂妄自大的人。走到今天，我已经深知自己是一个有自知之明的人。<br>]]>
    
    </summary>
    
      <category term="life" scheme="http://elevensky.github.io/tags/life/"/>
    
      <category term="生活" scheme="http://elevensky.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
</feed>
